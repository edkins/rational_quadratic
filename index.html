<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

let params = {
    fixedPoints: [
        [-1.0, 0.0],
        [0.0, 0.0],
        [1.0, 0.0]
    ],
    a: [0, 0.0],
    ascale: [1.0, 0.0],
    b: [0, 0.0],
    bscale: [1.0, 0.0],
    z0: [0.0, 0.0],
    z0Scale: 2.0,
    mandelbrot: true,
    color: true,
    drag: "all",
    drag_start: [0.0, 0.0],
};
let glStuff = null;
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.9, 0.9, 1.0);

    // Mandelbrot vertex shader program
    const vsSource = `
        precision highp float;
        attribute vec2 aVertexPosition;
        uniform vec2 uz0;
        uniform float uz0Scale;
        uniform vec2 ua;
        uniform vec2 ub;
        uniform vec2 uascale;
        uniform vec2 ubscale;
        varying vec2 a;
        varying vec2 b;
        varying vec2 z0;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vec2 vp = aVertexPosition * vec2(1.0, 2.0);
            a = ua + mul(vp, uascale);
            b = ub + mul(vp, ubscale);
            z0 = uz0 + vp * uz0Scale;
        }
    `;

    // Mandelbrot/Julia fragment shader program
    const fsSource = `
        precision highp float;
        varying vec2 a;
        varying vec2 b;
        varying vec2 z0;
        uniform bool uMandelbrot;
        uniform bool uColor;

        const vec2 two = vec2(2.0, 0.0);
        const vec2 one = vec2(1.0, 0.0);

        vec2 csqrt(vec2 z) {
            float r = length(z);
            float theta = atan(z.y, z.x);
            return vec2(
                sqrt(r) * cos(theta / 2.0),
                sqrt(r) * sin(theta / 2.0)
            );
        }

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        vec4 solve_quadratic(vec2 a, vec2 b, vec2 c) {
            vec2 discriminant = csqrt(mul(b, b) - 4.0 * mul(a, c));
            vec2 root1 = div(-b + discriminant, 2.0 * a);
            vec2 root2 = div(-b - discriminant, 2.0 * a);
            return vec4(root1, root2);  // return both roots packed together
        }

        vec4 mandelbrot(vec2 actual_z0) {
            vec2 z = actual_z0;
            const int max_iteration = 200;
            int iter = 0;
            vec2 prevPrevZ = vec2(100000.0, 0.0);
            vec2 prevZ = vec2(-100000.0, 0.0);
            vec3 color = vec3(0.0, 0.0, 0.0);
            float delta = 1.0 / float(max_iteration);
            for (int iteration = 0; iteration < max_iteration; iteration++) {
                vec2 z2 = mul(z, z);
                z = div(
                    mul(a, z2) + mul(b - one, z),
                    mul(a - one, z) + b
                );
                if (length(z) > 100.0) {
                    // color += vec3(delta * float(max_iteration - iteration), 0.0, 0.0);
                    // break;
                    color += vec3(delta, 0.0, 0.0);
                } else if (length(z - prevPrevZ) < 0.1) {
                    if (uColor) {
                        if (length(z) < 0.05) {
                            color += vec3(0.0, delta, 0.0);
                        } else if (length(z - one) < 0.05) {
                            color += vec3(0.0, 0.0, delta);
                        } else {
                            color += vec3(delta, delta, delta);
                        }
                    } else {
                        color += vec3(delta, delta, delta);
                    }
                    iter++;
                }
                prevPrevZ = prevZ;
                prevZ = z;
            }
            return vec4(color, 1.0);
        }

        void main(void) {
            if (uMandelbrot) {
                vec4 roots = solve_quadratic(
                    mul(a, a - one),
                    2.0 * mul(a, b),
                    mul(b, b - one)
                );
                gl_FragColor = 0.5 * mandelbrot(roots.xy) + 
                               0.5 * mandelbrot(roots.zw);
            } else {
                gl_FragColor = mandelbrot(z0);
            }
        }
    `;


    // Initialize shaders
    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);
    ctx.useProgram(shaderProgram);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    return {
        shaderProgram,
        aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
        uMandelbrot: ctx.getUniformLocation(shaderProgram, "uMandelbrot"),
        uz0: ctx.getUniformLocation(shaderProgram, "uz0"),
        uz0Scale: ctx.getUniformLocation(shaderProgram, "uz0Scale"),
        ua: ctx.getUniformLocation(shaderProgram, "ua"),
        ub: ctx.getUniformLocation(shaderProgram, "ub"),
        uascale: ctx.getUniformLocation(shaderProgram, "uascale"),
        ubscale: ctx.getUniformLocation(shaderProgram, "ubscale"),
        uColor: ctx.getUniformLocation(shaderProgram, "uColor"),
        vertexBuffer,
    };
}

function paint() {
    const stuff = glStuff
    const ctx = document.getElementById("canvas").getContext("webgl");
    ctx.clear(ctx.COLOR_BUFFER_BIT);
    ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // Draw the Julia or Mandelbrot set
    ctx.useProgram(stuff.shaderProgram);
    if (params.mandelbrot) {
        ctx.uniform1i(stuff.uMandelbrot, true);
        ctx.uniform1f(stuff.uz0Scale, 0.0);
        ctx.uniform2f(stuff.ua, params.a[0], params.a[1]);
        ctx.uniform2f(stuff.uascale, params.ascale[0], params.ascale[1]);
        ctx.uniform2f(stuff.ub, params.b[0], params.b[1]);
        ctx.uniform2f(stuff.ubscale, params.bscale[0], params.bscale[1]);
    } else {
        ctx.uniform1i(stuff.uMandelbrot, false);
        ctx.uniform1f(stuff.uz0Scale, params.z0Scale);
        ctx.uniform2f(stuff.ua, params.a[0], params.a[1]);
        ctx.uniform2f(stuff.ub, params.b[0], params.b[1]);
        ctx.uniform2f(stuff.uascale, 0.0, 0.0);
        ctx.uniform2f(stuff.ubscale, 0.0, 0.0);
    }
    ctx.uniform1i(stuff.uColor, params.color);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);

    document.getElementById("button_ab").classList.remove("active");
    document.getElementById("button_bc").classList.remove("active");
    document.getElementById("button_ca").classList.remove("active");
    document.getElementById("button_all").classList.remove("active");
    if (params.drag === "ab") {
        document.getElementById("button_ab").classList.add("active");
    } else if (params.drag === "bc") {
        document.getElementById("button_bc").classList.add("active");
    } else if (params.drag === "ca") {
        document.getElementById("button_ca").classList.add("active");
    } else if (params.drag === "all") {
        document.getElementById("button_all").classList.add("active");
    }
}

function mousedown() {
    const x = event.clientX;
    const y = event.clientY;
    params.drag_start = [x, y];
    // update_point(x,y, false, params.last_alternate);
    event.preventDefault();
}

function mousemove() {
    if (event.buttons === 1) {
        const x = event.clientX;
        const y = event.clientY;
        update_point(-(x - params.drag_start[0]) / 1000, (y - params.drag_start[1]) / 1000, true, params.last_alternate);
        params.drag_start = [x, y];
    }

    if (event.buttons === 2) {
        const delta = event.deltaY * 0.001;
        if (params.mandelbrot) {
            if (params.drag === "a" || params.drag === "all") {
                params.ascale[0] *= (1 + delta * 0.1);
                params.ascale[1] *= (1 + delta * 0.1);
            }
            if (params.drag === "b" || params.drag === "all") {
                params.bscale[0] *= (1 + delta * 0.1);
                params.bscale[1] *= (1 + delta * 0.1);
            }
        } else {
            params.z0Scale *= (1 + delta * 0.1);
        }
        paint();
    }
    event.preventDefault();
}

function mousewheel() {
}

function update_point(x, y, relative, alternate) {
    let ndcX = x;
    let ndcY = y;
    if (!relative) {
        const rect = event.target.getBoundingClientRect();
        const canvasX = x - rect.left;
        const canvasY = y - rect.top;
        ndcX = (canvasX / rect.width) * 2 - 1;
        ndcY = 1 - (canvasY / rect.height) * 2;
    }

    if (params.mandelbrot) {
        if (relative) {
            params.a[0] += ndcX * params.ascale[0] - ndcY * params.ascale[1];
            params.a[1] += ndcX * params.ascale[1] + ndcY * params.ascale[0];
            params.b[0] += ndcX * params.bscale[0] - ndcY * params.bscale[1];
            params.b[1] += ndcX * params.bscale[1] + ndcY * params.bscale[0];
        } else {
            params.a = [ndcX, ndcY];
            params.b = [ndcX, ndcY];
        }
    }
    params.last_alternate = alternate;

    paint(glStuff);
}

function keydown() {
    const key = event.key;
    if (key === "ArrowLeft") {
        update_point(-0.0005, 0, true, false);
    } else if (key === "ArrowRight") {
        update_point(0.0005, 0, true, false);
    } else if (key === "ArrowUp") {
        update_point(0, -0.0005, true, false);
    } else if (key === "ArrowDown") {
        update_point(0, 0.0005, true, false);
    } else if (key == "a") {
        update_point(-0.0005, 0, true, true);
    } else if (key == "d") {
        update_point(0.0005, 0, true, true);
    } else if (key == "w") {
        update_point(0, -0.0005, true, true);
    } else if (key == "s") {
        update_point(0, 0.0005, true, true);
    } else if (key === "a") {
        params.drag = "a";
    } else if (key === "b") {
        params.drag = "b";
    } else if (key === "z") {
        params.drag = "all";
    } else if (key == "m") {
        params.mandelbrot = true;
        paint();
    } else if (key == "j") {
        params.mandelbrot = false;
        paint();
    }
}

let touches = new Map();

function touchstart() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];
    const touch = {
      pageX: changedTouch.pageX,
      pageY: changedTouch.pageY,
    };
    paint();
    touches.set(changedTouch.identifier, touch);
}

function touchend() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];
    const ongoingTouch = touches.get(changedTouch.identifier);
    const deltaX = changedTouch.pageX - ongoingTouch.pageX;
    const deltaY = changedTouch.pageY - ongoingTouch.pageY;
    if (params.drag === "a" || params.drag === "all") {
        params.a[0] -= deltaX * 0.0001;
        params.a[1] += deltaY * 0.0001;
    }
    if (params.drag === "b" || params.drag === "all") {
        params.b[0] -= deltaX * 0.0001;
        params.b[1] += deltaY * 0.0001;
    }
    paint();
    touches.delete(changedTouch.identifier);
}

function doubletouch() {
    const touch1 = event.changedTouches[0];
    const touch2 = event.changedTouches[1];
    const prevTouch1 = touches.get(touch1.identifier);
    const prevTouch2 = touches.get(touch2.identifier);
    const prevDist = Math.hypot(
        prevTouch2.pageX - prevTouch1.pageX,
        prevTouch2.pageY - prevTouch1.pageY);
    const newDist = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY);
    const prevAngle = Math.atan2(
        prevTouch2.pageY - prevTouch1.pageY,
        prevTouch2.pageX - prevTouch1.pageX);
    const newAngle = Math.atan2(
        touch2.pageY - touch1.pageY,
        touch2.pageX - touch1.pageX);
    const angleDelta = newAngle - prevAngle;
    const scaleX = Math.cos(angleDelta) * prevDist / newDist;
    const scaleY = Math.sin(angleDelta) * prevDist / newDist;
    if (params.mandelbrot) {
        if (params.drag === "ca" || params.drag === "all") {
            params.ascale = [
                params.ascale[0] * scaleX - params.ascale[1] * scaleY,
                params.ascale[0] * scaleY + params.ascale[1] * scaleX
            ];
        }
        if (params.drag === "bc" || params.drag === "all") {
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
        if (params.drag === "ab") {
            let aincrx = params.ascale[0] * scaleX - params.ascale[1] * scaleY - params.ascale[0];
            let aincry = params.ascale[0] * scaleY + params.ascale[1] * scaleX - params.ascale[1];
            let bincrx = params.bscale[0] * scaleX - params.bscale[1] * scaleY - params.bscale[0];
            let bincry = params.bscale[0] * scaleY + params.bscale[1] * scaleX - params.bscale[1];
            let incrx = (aincrx + bincrx) / 2;
            let incry = (aincry + bincry) / 2;
            params.ascale[0] += incrx;
            params.ascale[1] += incry;
            params.bscale[0] -= incrx;
            params.bscale[1] -= incry;
        }
    } else {
        params.z0Scale /= scale;
    }
    paint();
    prevTouch1.pageX = touch1.pageX;
    prevTouch1.pageY = touch1.pageY;
    prevTouch2.pageX = touch2.pageX;
    prevTouch2.pageY = touch2.pageY;
}

function touchmove() {
    event.preventDefault();
    if (event.changedTouches.length === 2) {
        doubletouch();
        return;
    }
    if (event.changedTouches.length !== 1) {
        return;
    }
    const changedTouch = event.changedTouches[0];
    const ongoingTouch = touches.get(changedTouch.identifier);
    if (!ongoingTouch) {
        return;
    }
    const deltaX = -(changedTouch.pageX - ongoingTouch.pageX) * 0.005;
    const deltaY = (changedTouch.pageY - ongoingTouch.pageY) * 0.005;
    ongoingTouch.pageX = changedTouch.pageX;
    ongoingTouch.pageY = changedTouch.pageY;
    if (params.drag === "ca") {
        params.a[0] += 2 * deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += 2 * deltaY * params.ascale[0] + deltaX * params.ascale[1];
    }
    if (params.drag === "bc") {
        params.b[0] += 2 * deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += 2 * deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
    if (params.drag === "ab") {
        const cscale = [
            (params.ascale[0] + params.bscale[0]),
            (params.ascale[1] + params.bscale[1]),
        ]
        params.a[0] += deltaX * cscale[0] - deltaY * cscale[1];
        params.a[1] += deltaY * cscale[0] + deltaX * cscale[1];
        params.b[0] -= deltaX * cscale[0] - deltaY * cscale[1];
        params.b[1] -= deltaY * cscale[0] + deltaX * cscale[1];
    }
    if (params.drag === "all") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
    paint();
}

function start() {
    glStuff = setup();
    paint();
}

window.onload = start;
    </script>
    <style>
button {
    padding: 10px;
}
button.active {
    background: #ffaaaa;
}
    </style>
</head>
<body onkeydown="keydown()">
    <button id="button_ab" onclick="params.drag='ab'; paint()">AB</button>
    <button id="button_bc" onclick="params.drag='bc'; paint()">BC</button>
    <button id="button_ca" onclick="params.drag='ca'; paint()">CA</button>
    <button id="button_all" onclick="params.drag='all'; paint()">All</button>
    <br>
    <canvas id="canvas" width="400" height="800" onmousedown="mousedown()" onmousemove="mousemove()" onwheel="mousewheel()" ontouchstart="touchstart()" ontouchmove="touchmove()" ontouchend="touchend()"></canvas>
</body>
</html>