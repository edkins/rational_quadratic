<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

let params = {
    fixedPoints: [
        [-1.0, 0.0],
        [0.0, 0.0],
        [1.0, 0.0]
    ],
    G: [0.0, 0.0],
    Gscale: [2.0, 0.0],
    H: [0.0, 0.0],
    Hscale: [2.0, 0.0],
    sscale: [1.0, 0.0],
    z0: [0.0, 0.0],
    z0Scale: 1.0,
    mode: "G",  // "G" or "H" for mandelbrot, or else "z0" for julia
    color: true,
};
let glStuff = null;
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.9, 0.9, 1.0);

    // Mandelbrot vertex shader program
    const vsSource = `
        precision mediump float;
        attribute vec2 aVertexPosition;
        uniform vec2 uz0;
        uniform float uz0Scale;
        uniform vec2 a;
        uniform vec2 b;
        uniform vec2 c;
        uniform vec2 uG;
        uniform vec2 uH;
        uniform vec2 uGscale;
        uniform vec2 uHscale;
        varying vec2 va;
        varying vec2 vb;
        varying vec2 vc;
        varying vec2 vG;
        varying vec2 vH;
        varying vec2 vz0;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            va = a;
            vb = b;
            vc = c;
            vG = uG + mul(aVertexPosition, uGscale);
            vH = uH + mul(aVertexPosition, uHscale);
            vz0 = uz0 + aVertexPosition * uz0Scale;
        }
    `;

    // Mandelbrot/Julia fragment shader program
    const fsSource = `
        precision mediump float;
        varying vec2 va;
        varying vec2 vb;
        varying vec2 vc;
        varying vec2 vG;
        varying vec2 vH;
        varying vec2 vz0;
        uniform vec2 a;
        uniform vec2 b;
        uniform vec2 c;
        uniform bool uMandelbrot;
        uniform bool uColor;

        vec2 csqrt(vec2 z) {
            float r = length(z);
            float theta = atan(z.y, z.x);
            return vec2(
                sqrt(r) * cos(theta / 2.0),
                sqrt(r) * sin(theta / 2.0)
            );
        }

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        vec4 solve_quadratic(vec2 a, vec2 b, vec2 c) {
            vec2 discriminant = csqrt(mul(b, b) - 4.0 * mul(a, c));
            vec2 root1 = div(-b + discriminant, 2.0 * a);
            vec2 root2 = div(-b - discriminant, 2.0 * a);
            return vec4(root1, root2);  // return both roots packed together
        }

        vec4 mandelbrot(
            vec2 A,
            vec2 B,
            vec2 C,
            vec2 D,
            vec2 E,
            vec2 z0
        ) {
            vec2 z = z0;
            const int max_iteration = 200;
            int iter = 0;
            vec2 prevPrevZ = vec2(100000.0, 0.0);
            vec2 prevZ = vec2(-100000.0, 0.0);
            vec3 color = vec3(0.0, 0.0, 0.0);
            float delta = 1.0 / float(max_iteration);
            for (int iteration = 0; iteration < max_iteration; iteration++) {
                vec2 z2 = mul(z, z);
                z = div(
                    mul(A, z2) + mul(B, z) + C,
                    z2 + mul(D, z) + E
                );
                if (length(z - prevPrevZ) < 0.1) {
                    if (uColor) {
                        if (length(z - a) < 0.05) {
                            color += vec3(0.0, delta, 0.0);
                        } else if (length(z - b) < 0.05) {
                            color += vec3(0.0, 0.0, delta);
                        } else if (length(z - c) < 0.05) {
                            color += vec3(delta, 0.0, 0.0);
                        } else {
                            color += vec3(delta, delta, delta);
                        }
                    } else {
                        color += vec3(delta, delta, delta);
                    }
                    iter++;
                }
                prevPrevZ = prevZ;
                prevZ = z;
            }
            return vec4(color, 1.0);
        }

        void main(void) {
            vec2 A = vG;
            vec2 D = A - (va + vb + vc);
            vec2 B = vH;
            vec2 E = B + mul(va, vb) + mul(va, vc) + mul(vb, vc);
            vec2 C = mul(va, mul(vb, vc));

            if (uMandelbrot) {
                vec4 roots = solve_quadratic(
                    mul(A, D) - B,
                    2.0 * (mul(A,E) - C),
                    mul(B, E) - mul(C, D)
                );
                gl_FragColor = 0.5 * mandelbrot(A, B, C, D, E, roots.xy) + 
                               0.5 * mandelbrot(A, B, C, D, E, roots.zw);
            } else {
                gl_FragColor = mandelbrot(A, B, C, D, E, vz0);
            }
        }
    `;


    // Initialize shaders
    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);
    ctx.useProgram(shaderProgram);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    return {
        shaderProgram,
        aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
        uMandelbrot: ctx.getUniformLocation(shaderProgram, "uMandelbrot"),
        uz0: ctx.getUniformLocation(shaderProgram, "uz0"),
        uz0Scale: ctx.getUniformLocation(shaderProgram, "uz0Scale"),
        ua: ctx.getUniformLocation(shaderProgram, "a"),
        ub: ctx.getUniformLocation(shaderProgram, "b"),
        uc: ctx.getUniformLocation(shaderProgram, "c"),
        uG: ctx.getUniformLocation(shaderProgram, "uG"),
        uGscale: ctx.getUniformLocation(shaderProgram, "uGscale"),
        uH: ctx.getUniformLocation(shaderProgram, "uH"),
        uHscale: ctx.getUniformLocation(shaderProgram, "uHscale"),
        uColor: ctx.getUniformLocation(shaderProgram, "uColor"),
        vertexBuffer,
    };
}

function paint(stuff) {
    const ctx = document.getElementById("canvas").getContext("webgl");
    ctx.clear(ctx.COLOR_BUFFER_BIT);
    ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
    
    // Draw the Julia or Mandelbrot set
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform2f(stuff.uz0, params.z0[0], params.z0[1]);
    ctx.uniform1f(stuff.uz0Scale, (params.mode === "z0") ? params.z0Scale : 0.0);
    ctx.uniform1i(stuff.uMandelbrot, params.mode !== "z0");
    ctx.uniform2f(stuff.ua, params.fixedPoints[0][0], params.fixedPoints[0][1]);
    ctx.uniform2f(stuff.ub, params.fixedPoints[1][0], params.fixedPoints[1][1]);
    ctx.uniform2f(stuff.uc, params.fixedPoints[2][0], params.fixedPoints[2][1]);
    ctx.uniform2f(stuff.uG, params.G[0], params.G[1]);
    if (params.mode === "G") {
        ctx.uniform2f(stuff.uGscale, params.Gscale[0], params.Gscale[1]);
        ctx.uniform2f(stuff.uHscale, 0.0, 0.0);
    } else if (params.mode === "H") {
        ctx.uniform2f(stuff.uGscale, 0.0, 0.0);
        ctx.uniform2f(stuff.uHscale, params.Hscale[0], params.Hscale[1]);
    } else if (params.mode === "s") {
        ctx.uniform2f(stuff.uGscale, params.Gscale[0], params.Gscale[1]);
        ctx.uniform2f(stuff.uHscale, params.sscale[0] * params.Gscale[0] - params.sscale[1] * params.Gscale[1],
                                      params.sscale[0] * params.Gscale[1] + params.sscale[1] * params.Gscale[0]);
    } else {
        ctx.uniform2f(stuff.uGscale, 0.0, 0.0);
        ctx.uniform2f(stuff.uHscale, 0.0, 0.0);
    }
    ctx.uniform2f(stuff.uH, params.H[0], params.H[1]);
    ctx.uniform1i(stuff.uColor, params.color);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
}


function mousedown() {
    const x = event.clientX;
    const y = event.clientY;
    update_point(x,y, false);
}

function mousemove() {
    if (event.buttons === 1) {
        const x = event.clientX;
        const y = event.clientY;
        update_point(x, y, false);
    }
}

function update_point(x, y, relative) {
    let ndcX = x;
    let ndcY = y;
    if (!relative) {
        const rect = event.target.getBoundingClientRect();
        const canvasX = x - rect.left;
        const canvasY = y - rect.top;
        ndcX = (canvasX / rect.width) * 2 - 1;
        ndcY = 1 - (canvasY / rect.height) * 2;
    }

    if (params.mode === "G") {
        if (relative) {
            params.H[0] += ndcX;
            params.H[1] += ndcY;
        } else {
            params.H = [ndcX, ndcY];
        }
    } else if (params.mode === "H") {
        if (relative) {
            params.G[0] += ndcX;
            params.G[1] += ndcY;
        } else {
            params.G = [ndcX, ndcY];
        }
    } else if (params.mode === "s") {
        if (relative) {
            params.sscale[0] += ndcX;
            params.sscale[1] += ndcY;
        } else {
            params.sscale = [ndcX, ndcY];
        }
    } else if (params.mode === "z0") {
        // params.z0 = [ndcX * params.z0Scale, ndcY * params.z0Scale];
    }

    paint(glStuff);
}

function keydown() {
    const key = event.key;
    if (key === "ArrowLeft") {
        update_point(-0.0005, 0, true);
    } else if (key === "ArrowRight") {
        update_point(0.0005, 0, true);
    } else if (key === "ArrowUp") {
        update_point(0, -0.0005, true);
    } else if (key === "ArrowDown") {
        update_point(0, 0.0005, true);
    } else if (key == "g") {
        params.mode = "G";
        paint(glStuff);
    } else if (key == "h") {
        params.mode = "H";
        paint(glStuff);
    } else if (key == "s") {
        params.mode = "s";
        paint(glStuff);
    }
}

function start() {
    glStuff = setup();
    paint(glStuff);
}

window.onload = start;
    </script>
</head>
<body onkeydown="keydown()">
    <canvas id="canvas" width="1200" height="1200" onmousedown="mousedown()" onmousemove="mousemove()"></canvas>
</body>
</html>