<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

const A = 3;
const B = 3;
const showDots = false;
const showHigh = false;

const uPowersArrays = {
    1: [0,1],
    2: [0,0,1],
    3: [0,-1,1,1],
    4: [0,0,-1,1,1],
    5: [0,-1,0,1,1,1],
}

let params = {
    ccenter: [-0.5, 0.0],
    cscale: [2.5, 0.0],

    c: [-0.0, 0.0],
    z0: [0.0, 0.0],
    z0Scale: [1.2, 0.0],
    mandelbrot: true,

    color: true,
    drag: "zoom",
    drag_start: [0.0, 0.0],
    timer: null,
    last_moved: 0,
    high_count: 0,
    plot_points: [],
    plot_colors: [],
    plot_sizes: [],
    unscaled_points: [],

    jMaxIter: 100,

    frac: {num:0,denom:7}
    // frac: binfrac("","000111")
};
let glStuff = null;
let touches = new Map();

function binfrac(fixed, recurring) {
    let num = 0;
    if (fixed !== "") {
        num = parseInt(fixed, 2);
    }
    let denom = Math.pow(2, fixed.length);

    if (recurring !== undefined && recurring !== "") {
        let pot = Math.pow(2, recurring.length);
        num = num * (pot - 1) + parseInt(recurring, 2);
        denom *= pot - 1;
    }

    console.log("binfrac",num,denom);
    return {num, denom};
}

function fragmentShaderSource(max_iter, max_period) {
    return `
        precision highp float;
        varying vec2 c;
        varying vec2 z0;
        uniform bool uMandelbrot;
        uniform float uBailout;
        uniform float uFracNum;
        uniform float uFracDenom;
        uniform vec3 uPalette[${palette.length}];
        uniform int uMaxIter;
        const vec2 one = vec2(1.0, 0.0);

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 csquare(vec2 z) {
            return vec2(
                z.x * z.x - z.y * z.y,
                2.0 * z.x * z.y
            );
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        vec2 csqrt(vec2 z) {
            float r = length(z);
            float theta = atan(z.y, z.x);
            return vec2(
                sqrt(r) * cos(theta / 2.0),
                sqrt(r) * sin(theta / 2.0)
            );
        }

        vec2 other_csqrt(vec2 z) {
            float r = sqrt(length(z));
            float theta = atan(-z.y, -z.x);
            return vec2(
                -r * sin(theta / 2.0),
                r * cos(theta / 2.0)
            );
        }

        float angle_distance(float a, float b) {
            float twopi = 6.28318530718;
            float diff = mod(b - a, twopi);
            return min(diff, twopi - diff);
        }

        float closest_half_angle(float theta, float target) {
            float c0 = theta * 0.5;
            float c1 = c0 + 3.14159265359;
            float d0 = angle_distance(c0, target);
            float d1 = angle_distance(c1, target);
            return d0 < d1 ? c0 : c1;
        }

        float closest_angle(float c0, float c1, float target) {
            float d0 = angle_distance(c0, target);
            float d1 = angle_distance(c1, target);
            return d0 < d1 ? c0 : c1;
        }

        float atan2(vec2 z) {
            return atan(z.y, z.x);
        }

        vec2 cexp(vec2 z) {
            return exp(z.x) * vec2(cos(z.y), sin(z.y));
        }

        vec2 clog(vec2 z) {
            return vec2(log(length(z)), atan(z.y, z.x));
        }

        vec2 cpow(vec2 z, int p) {
            float r = pow(length(z), float(p));
            float theta = atan(z.y, z.x) * float(p);
            return vec2(
                r * cos(theta),
                r * sin(theta)
            );
        }

        float nearest(float course, float fine) {
            return fine + floor(course - fine + 0.5);
        }

        struct D {
            vec2 value;
            vec2 dc;
        };

        D dsquare(D z) {
            return D(
                mul(z.value, z.value),
                2.0 * mul(z.value, z.dc));
        }

        D dmul(D x, D y) {
            return D(
                mul(x.value, y.value),
                mul(x.value, y.dc) + mul(y.value, x.dc)
            );
        }

        D dadd(D a, D b) {
            return D(
                a.value + b.value,
                a.dc + b.dc);
        }

        D dadd_const(D a, vec2 c) {
            return D(
                a.value + c,
                a.dc
            );
        }

        D dsqrt(D z) {
            vec2 s = csqrt(z.value);
            return D(
                s,
                0.5 * div(z.dc, s)
            );
        }

        D dbar(D z) {
            return D(
                vec2(-z.value.x, z.value.y),
                z.dc
            );
        }

        vec4 mandelbrot(vec2 actual_z0) {
            vec2 z = actual_z0;
            int escaped = -1;
            vec2 keep = one;
            bool even = true;
            float theta = 0.0;
            float denom = 4.0;
            for (int iteration = 1; iteration < ${max_iter}; iteration++) {
                theta *= 2.0;
                float fine = atan2(z) / 6.28318530718;
                float thing = theta - fine + 0.5;
                float fl = floor(thing);
                theta = fine + fl;
                bool yikes = thing - fl < 0.05 || thing - fl > 0.95;

                // if (yikes) {
                //     return vec4(0.6, 0.0, 0.0, 1.0);
                // }

                denom *= 0.5;

                z = csquare(z) + c;
                even = !even;

                if (length(z) > uBailout) {
                    escaped = iteration;
                    break;
                }
                if (iteration >= uMaxIter) {
                    break;
                }
            }

            if (escaped == -1) {
                return vec4(0.4, 0.0, 0.0, 1.0);
            }
            if (length(z) - uBailout < 0.1) {
                return vec4(0.0, 0.4, 0.0, 1.0);
            }
            theta = mod(theta * denom, 1.0);
            float fiter = 0.2 + log(float(escaped)) / 15.0;
            vec4 color = vec4(theta, theta, theta * 2.0, 1.0);
            return color;
        }

        void main(void) {
            if (uMandelbrot) {
                gl_FragColor = mandelbrot(c);
            } else {
                gl_FragColor = mandelbrot(z0);
            }
        }
    `;
}
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.9, 0.9, 1.0);

    // Mandelbrot vertex shader program
    const vsSource = `
        precision highp float;
        attribute vec2 aVertexPosition;
        uniform vec2 uz0;
        uniform vec2 uz0Scale;
        uniform vec2 uc;
        uniform vec2 ucscale;
        uniform vec2 uNudge;
        varying vec2 c;
        varying vec2 z0;
        uniform vec2 aspect;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vec2 vp = aVertexPosition * aspect + uNudge;
            c = uc + mul(vp, ucscale);
            z0 = uz0 + mul(vp, uz0Scale);
        }
    `;

    // Mandelbrot/Julia fragment shader program
    const fsSource = fragmentShaderSource(200, 32);
    const fsSourceHigh = fragmentShaderSource(50000, 100);

    // Initialize shaders
    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);

    // Initialize shaders (high iteration count)
    const fragmentShaderHigh = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderHigh, fsSourceHigh);
    ctx.compileShader(fragmentShaderHigh);
    if (!ctx.getShaderParameter(fragmentShaderHigh, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the high iteration shader: " +
            ctx.getShaderInfoLog(fragmentShaderHigh));
        return null;
    }
    const shaderProgramHigh = ctx.createProgram();
    ctx.attachShader(shaderProgramHigh, vertexShader);
    ctx.attachShader(shaderProgramHigh, fragmentShaderHigh);
    ctx.linkProgram(shaderProgramHigh);

    // Shaders for texture blitting
    const vsSourceBlit = `
        attribute vec2 aVertexPosition;
        varying vec2 vTexCoord;
        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vTexCoord = (aVertexPosition + vec2(1.0, 1.0)) * 0.5;
        }
    `;
    const fsSourceBlit = `
        precision highp float;
        varying vec2 vTexCoord;
        uniform sampler2D uTexture;
        void main(void) {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;
    const vertexShaderBlit = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderBlit, vsSourceBlit);
    ctx.compileShader(vertexShaderBlit);
    const fragmentShaderBlit = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderBlit, fsSourceBlit);
    ctx.compileShader(fragmentShaderBlit);
    if (!ctx.getShaderParameter(vertexShaderBlit, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderBlit, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the blit shaders: " +
            ctx.getShaderInfoLog(vertexShaderBlit) + " " +
            ctx.getShaderInfoLog(fragmentShaderBlit));
        return null;
    }
    const shaderProgramBlit = ctx.createProgram();
    ctx.attachShader(shaderProgramBlit, vertexShaderBlit);
    ctx.attachShader(shaderProgramBlit, fragmentShaderBlit);
    ctx.linkProgram(shaderProgramBlit);

    // Shaders for point markers
    const vsSourcePoint = `
        precision highp float;
        uniform vec2 uVertexPosition;
        uniform float uPointSize;
        uniform vec2 aspect;
        void main(void) {
            gl_Position = vec4(uVertexPosition / aspect, 0.0, 1.0);
            gl_PointSize = uPointSize;
        }
    `;
    const fsSourcePoint = `
        precision highp float;
        uniform vec3 uColor;
        void main(void) {
            gl_FragColor = vec4(uColor, 1.0);
        }
    `;
    const vertexShaderPoint = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderPoint, vsSourcePoint);
    ctx.compileShader(vertexShaderPoint);
    const fragmentShaderPoint = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderPoint, fsSourcePoint);
    ctx.compileShader(fragmentShaderPoint);
    if (!ctx.getShaderParameter(vertexShaderPoint, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderPoint, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the point shaders: " +
            ctx.getShaderInfoLog(vertexShaderPoint) + " " +
            ctx.getShaderInfoLog(fragmentShaderPoint));
        return null;
    }
    const shaderProgramPoint = ctx.createProgram();
    ctx.attachShader(shaderProgramPoint, vertexShaderPoint);
    ctx.attachShader(shaderProgramPoint, fragmentShaderPoint);
    ctx.linkProgram(shaderProgramPoint);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    // Create texture to hold low-iteration Mandelbrot image
    const fbWidth = ctx.canvas.width;
    const fbHeight = ctx.canvas.height;
    const destTexture = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTexture);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidth, fbHeight, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render low-iteration Mandelbrot image into
    const framebuffer = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffer);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTexture, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    // Create texture to hold high-iteration Mandelbrot image
    const fbWidthHigh = fbWidth;
    const fbHeightHigh = fbHeight;
    const destTextureHigh = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTextureHigh);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidthHigh, fbHeightHigh, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render high-iteration Mandelbrot image into
    const framebufferHigh = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebufferHigh);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTextureHigh, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    return {
        main: {
            shaderProgram,
            aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgram, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgram, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgram, "uz0Scale"),
            uc: ctx.getUniformLocation(shaderProgram, "uc"),
            ucscale: ctx.getUniformLocation(shaderProgram, "ucscale"),
            uBailout: ctx.getUniformLocation(shaderProgram, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgram, "uBailin"),
            bailin: 0.002,
            bailout: 4,
            uNudge: ctx.getUniformLocation(shaderProgram, "uNudge"),
            vertexBuffer,
            destTexture,
            framebuffer,
            fbWidth,
            fbHeight,
            uBrightness: ctx.getUniformLocation(shaderProgram, "uBrightness"),
            brightness: 0.02,
            uAspect: ctx.getUniformLocation(shaderProgram, "aspect"),
            uFracNum: ctx.getUniformLocation(shaderProgram, "uFracNum"),
            uFracDenom: ctx.getUniformLocation(shaderProgram, "uFracDenom"),
            uPowers: ctx.getUniformLocation(shaderProgram, "uPowers"),
            uPalette: ctx.getUniformLocation(shaderProgram, "uPalette"),
            uMaxIter: ctx.getUniformLocation(shaderProgram, "uMaxIter"),
        },
        high: {
            shaderProgram: shaderProgramHigh,
            aVertexPosition: ctx.getAttribLocation(shaderProgramHigh, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgramHigh, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgramHigh, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgramHigh, "uz0Scale"),
            uc: ctx.getUniformLocation(shaderProgramHigh, "uc"),
            uascale: ctx.getUniformLocation(shaderProgramHigh, "uascale"),
            ucscale: ctx.getUniformLocation(shaderProgramHigh, "ucscale"),
            uBailout: ctx.getUniformLocation(shaderProgramHigh, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgramHigh, "uBailin"),
            bailin: 0.001,
            bailout: 4,
            uNudge: ctx.getUniformLocation(shaderProgramHigh, "uNudge"),
            vertexBuffer,
            destTexture: destTextureHigh,
            framebuffer: framebufferHigh,
            fbWidth: fbWidthHigh,
            fbHeight: fbHeightHigh,
            uBrightness: ctx.getUniformLocation(shaderProgramHigh, "uBrightness"),
            brightness: 0.02,
            uAspect: ctx.getUniformLocation(shaderProgramHigh, "aspect"),
            uFracNum: ctx.getUniformLocation(shaderProgramHigh, "uFracNum"),
            uFracDenom: ctx.getUniformLocation(shaderProgramHigh, "uFracDenom"),
            uPowers: ctx.getUniformLocation(shaderProgramHigh, "uPowers"),
            uPalette: ctx.getUniformLocation(shaderProgramHigh, "uPalette"),
            uMaxIter: ctx.getUniformLocation(shaderProgramHigh, "uMaxIter"),
        },
        blit: {
            shaderProgram: shaderProgramBlit,
            aVertexPosition: ctx.getAttribLocation(shaderProgramBlit, "aVertexPosition"),
            uTexture: ctx.getUniformLocation(shaderProgramBlit, "uTexture"),
            vertexBuffer,
        },
        point: {
            shaderProgram: shaderProgramPoint,
            uVertexPosition: ctx.getUniformLocation(shaderProgramPoint, "uVertexPosition"),
            uPointSize: ctx.getUniformLocation(shaderProgramPoint, "uPointSize"),
            uColor: ctx.getUniformLocation(shaderProgramPoint, "uColor"),
            uAspect: ctx.getUniformLocation(shaderProgramPoint, "aspect"),
        }
    };
}

function paintMandelbrot(ctx, stuff, nudgeX, nudgeY) {
    // Draw the Julia or Mandelbrot set
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform2f(stuff.uNudge, nudgeX, nudgeY);
    ctx.uniform2f(stuff.uAspect, ctx.canvas.width / Math.min(ctx.canvas.width, ctx.canvas.height), ctx.canvas.height / Math.min(ctx.canvas.width, ctx.canvas.height));
    ctx.uniform1f(stuff.uFracNum, params.frac.num);
    ctx.uniform1f(stuff.uFracDenom, params.frac.denom);
    ctx.uniform1f(stuff.uBailout, stuff.bailout);

    // ctx.uniform1iv(stuff.uPowers, uPowersArrays[B]);
    const paletteConcat = [];
    for (let i = 0; i < palette.length; i++) {
        paletteConcat.push(...palette[i]);
    }
    ctx.uniform3fv(stuff.uPalette, paletteConcat);

    if (params.mandelbrot) {
        ctx.uniform1i(stuff.uMandelbrot, true);
        ctx.uniform2f(stuff.uz0Scale, 0.0, 0.0);
        ctx.uniform2f(stuff.uc, params.ccenter[0], params.ccenter[1]);
        ctx.uniform2f(stuff.ucscale, params.cscale[0], params.cscale[1]);
        ctx.uniform1i(stuff.uMaxIter, 1000000);
    } else {
        ctx.uniform1i(stuff.uMandelbrot, false);
        ctx.uniform2f(stuff.uz0Scale, params.z0Scale[0], params.z0Scale[1]);
        ctx.uniform2f(stuff.uc, params.c[0], params.c[1]);
        ctx.uniform2f(stuff.ucscale, 0.0, 0.0);
        ctx.uniform2f(stuff.uz0, params.z0[0], params.z0[1]);
        ctx.uniform1i(stuff.uMaxIter, params.jMaxIter);
    }
    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
}

function blit_texture(ctx, stuff, texture) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.activeTexture(ctx.TEXTURE0);
    ctx.bindTexture(ctx.TEXTURE_2D, texture);
    ctx.uniform1i(stuff.uTexture, 0);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);

    ctx.bindTexture(ctx.TEXTURE_2D, null);
}

function draw_dots(ctx, stuff) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform2f(stuff.uAspect, ctx.canvas.width / Math.min(ctx.canvas.width, ctx.canvas.height), ctx.canvas.height / Math.min(ctx.canvas.width, ctx.canvas.height));

    for (let i = 0; i < params.plot_points.length; i++) {
        const pt = params.plot_points[i];
        const col = params.plot_colors[i];
        const size = params.plot_sizes[i];
        ctx.uniform1f(stuff.uPointSize, size);
        ctx.uniform2f(stuff.uVertexPosition, pt[0], pt[1]);
        ctx.uniform3f(stuff.uColor, col[0], col[1], col[2]);
        ctx.drawArrays(ctx.POINTS, 0, 1);
    }
}

function paint() {
    const ctx = document.getElementById("canvas").getContext("webgl");
    if (params.high_count === 0) {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.main.framebuffer);
        ctx.viewport(0, 0, glStuff.main.fbWidth, glStuff.main.fbHeight);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        paintMandelbrot(ctx, glStuff.main, 0, 0);

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        blit_texture(ctx, glStuff.blit, glStuff.main.destTexture);
        draw_dots(ctx, glStuff.point);

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        if (params.showHigh) {
            params.high_count += 1;
            params.timer = setTimeout(paint, 300);
        }
    } else {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.high.framebuffer);
        ctx.viewport(0, 0, glStuff.high.fbWidth, glStuff.high.fbHeight);

        if (params.high_count === 1) {
            ctx.clear(ctx.COLOR_BUFFER_BIT);
            paintMandelbrot(ctx, glStuff.high, 0, 0);
        } else {
            ctx.enable(ctx.BLEND);
            ctx.blendEquation(ctx.FUNC_ADD);
            ctx.blendFuncSeparate(ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA, ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA);
            ctx.blendColor(1.0, 1.0, 1.0, 1.0 / params.high_count);
            let nudgeX = (Math.random() - 0.5) * 0.5 / 100;
            let nudgeY = (Math.random() - 0.5) * 0.5 / 100;
            paintMandelbrot(ctx, glStuff.high, nudgeX, nudgeY);
            ctx.disable(ctx.BLEND);
        }

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        blit_texture(ctx, glStuff.blit, glStuff.high.destTexture);
        draw_dots(ctx, glStuff.point);

        params.high_count += 1;

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        if (params.high_count < 8) {
            params.timer = setTimeout(paint, 100);
        }
    }
}

function mousedown() {
}

function mousemove() {
    const x = event.clientX;
    const y = event.clientY;
    const originX = event.target.getBoundingClientRect().left;
    const originY = event.target.getBoundingClientRect().top;
    const hwidth = event.target.clientWidth / 2;
    const hheight = event.target.clientHeight / 2;
    const aspectX = event.target.clientWidth / Math.min(event.target.clientWidth, event.target.clientHeight);
    const aspectY = event.target.clientHeight / Math.min(event.target.clientWidth, event.target.clientHeight);
    const xy = [
        ((x - originX - hwidth) / hwidth) * aspectX,
        (-(y - originY - hheight) / hheight) * aspectY
    ];
    if (event.buttons === 1) {
        let param = (y - originY) / hheight;
        // param = Math.pow(param, 3) / 16;
        // params.c = [-0.75, param];
        params.mandelbrot = false;

        // params.c = [0.1255330111537578 + xy[0], 0.648284583511973];
        // params.c = [0.09918002123532474 + xy[0], 0.9572909508812188];
        params.c = [0.0 + 0.2 * xy[0], 0.98];
        // params.unscaled_points.push(params.c);
        // params.plot_colors.push([1,1,1]);
        // scale_mandelbrot_dots();
        set_jmaxiter()
        repaint();
    } else if (event.shiftKey && !params.mandelbrot) {
        set_julia_dots(add(params.z0, mul(params.z0Scale, xy)));
        repaint();
    }
}

function set_jmaxiter() {
    params.jMaxIter = 500;
    let z = [0,0];
    for (let i = 0; i < 500; i++) {
        z = add(mul(z,z), params.c);
        if (cnorm(z) > 16) {
            params.jMaxIter = i-1;
            break;
        }
    }
    set_julia_dots([0,0]);
}

function nearest(course, fine) {
    let thing = course - fine + 0.5;
    let floor = Math.floor(thing);
    let yikes = thing - floor < 0.05 || thing - floor > 0.95;
    // console.log(course, fine, thing, floor, yikes);
    return [fine + floor, yikes];
}

function set_julia_dots(start_z) {
    let z = start_z;
    params.unscaled_points = [];
    params.plot_colors = [];
    params.plot_sizes = [];
    let theta = 0;
    let yikes = false;
    let was_yikes = false;
    for (let i = 0; i < 500; i++) {
        z = add(mul(z,z), params.c);
        was_yikes = yikes;
        [theta,yikes] = nearest(2.0 * theta, Math.atan2(z[1], z[0]) / 6.28318530718);
        params.unscaled_points.push(z);
        // params.plot_colors.push((i == 0) ? [1.0, 0.0] : (i % 2) ? [1,0.5,0] : [0,1,0]);
        params.plot_colors.push(yikes ? [1.0, 0.0, 0.0] : was_yikes ? [1,0.7,0] : [1,1,0]);
        params.plot_sizes.push(i < 3 ? 16 : 8);
        if (cnorm(z) > 16) {
            break;
        }
    }
    scale_mandelbrot_dots();
}

function mousewheel() {
    const x = event.clientX;
    const y = event.clientY;
    const originX = event.target.getBoundingClientRect().left;
    const originY = event.target.getBoundingClientRect().top;
    const hwidth = event.target.clientWidth / 2;
    const hheight = event.target.clientHeight / 2;
    const aspectX = event.target.clientWidth / Math.min(event.target.clientWidth, event.target.clientHeight);
    const aspectY = event.target.clientHeight / Math.min(event.target.clientWidth, event.target.clientHeight);
    let sc = Math.pow(1.001, event.deltaY);
    const xy = [
        ((x - originX - hwidth) / hwidth) * aspectX,
        (-(y - originY - hheight) / hheight) * aspectY
    ];
    if (params.mandelbrot) {
        params.ccenter = add(params.ccenter, scale((1 - sc) * 1.2, mul(xy, params.cscale)));
        params.cscale[0] *= sc;
        params.cscale[1] *= sc;
    } else {
        params.z0 = add(params.z0, scale((1 - sc) * 1.2, mul(xy, params.z0Scale)));
        params.z0Scale = scale(sc, params.z0Scale);

    }
    scale_mandelbrot_dots();
    repaint();
}

function add(x, y) {
    return [
        x[0] + y[0],
        x[1] + y[1]
    ];
}

function add3(x, y, z) {
    return [
        x[0] + y[0] + z[0],
        x[1] + y[1] + z[1]
    ];
}

function add4(x, y, z, w) {
    return [
        x[0] + y[0] + z[0] + w[0],
        x[1] + y[1] + z[1] + w[1]
    ];
}

function sub(x, y) {
    return [
        x[0] - y[0],
        x[1] - y[1]
    ];
}

function mul(x, y) {
    return [
        x[0] * y[0] - x[1] * y[1],
        x[0] * y[1] + x[1] * y[0]
    ];
}

function div(x, y) {
    const denom = y[0] * y[0] + y[1] * y[1];
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function divEpsilon(x, y, epsilon) {
    const denom = y[0] * y[0] + y[1] * y[1] + epsilon;
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function recip(z) {
    return div([1.0,0.0], z);
}

function scale(r, c) {
    return [
        r * c[0],
        r * c[1]
    ];
}

function cnorm(c) {
    return Math.hypot(c[0], c[1]);
}

function cnorm_squared(c) {
    return c[0] * c[0] + c[1] * c[1];
}

function repaint() {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    paint();
}

function scale_rotate(scaleX, scaleY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.mandelbrot) {
        if (params.drag === "ca") {
            let c0 = -params.ascale[0] - params.bscale[0];
            let c1 = -params.ascale[1] - params.bscale[1];
            let cincrx = c0 * scaleX - c1 * scaleY - c0;
            let cincry = c0 * scaleY + c1 * scaleX - c1;
            params.ascale[0] -= cincrx;
            params.ascale[1] -= cincry;
        }
        if (params.drag === "bc") {
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
        if (params.drag === "ab") {
            let aincrx = params.ascale[0] * scaleX - params.ascale[1] * scaleY - params.ascale[0];
            let aincry = params.ascale[0] * scaleY + params.ascale[1] * scaleX - params.ascale[1];
            params.ascale[0] += aincrx;
            params.ascale[1] += aincry;
            params.bscale[0] -= aincrx;
            params.bscale[1] -= aincry;
        }
        if (params.drag === "all") {
            params.ascale = [
                params.ascale[0] * scaleX - params.ascale[1] * scaleY,
                params.ascale[0] * scaleY + params.ascale[1] * scaleX
            ];
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
    } else {
        params.z0Scale /= scale;
    }
}

function move(deltaX, deltaY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.drag === "ca") {
        const cscale = [
            (scale[0] + params.bscale[0]),
            (params.ascale[1] + params.bscale[1])
        ];
        params.a[0] += deltaX * cscale[0] - deltaY * cscale[1];
        params.a[1] += deltaY * cscale[0] + deltaX * cscale[1];
    }
    if (params.drag === "bc") {
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
    if (params.drag === "ab") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] -= deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.b[1] -= deltaY * params.ascale[0] + deltaX * params.ascale[1];
    }
    if (params.drag === "all") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
}

function update_buttons() {
    document.getElementById("button_distort").classList.remove("active");
    document.getElementById("button_zoom").classList.remove("active");
    if (params.drag === "distort") {
        document.getElementById("button_distort").classList.add("active");
    } else if (params.drag === "zoom") {
        document.getElementById("button_zoom").classList.add("active");
    }
}


function csqrt(z) {
    const r = Math.sqrt(cnorm(z));
    const theta = Math.atan2(z[1], z[0]);
    return [
        r * Math.cos(theta / 2.0),
        r * Math.sin(theta / 2.0)
    ];
}

function other_csqrt(z) {
    const r = Math.sqrt(cnorm(z));
    const theta = Math.atan2(-z[1], -z[0]);
    return [
        -r * Math.sin(theta / 2.0),
        r * Math.cos(theta / 2.0)
    ];
}

function solve_quadratic(a, b, c) {
    const discriminant = csqrt(sub(mul(b, b), scale(4.0, mul(a, c))));
    const root1 = div(sub(discriminant, b), scale(2.0, a));
    return root1;
}

function scale_mandelbrot_dots() {
    params.plot_points = [];
    for (let i = 0; i < params.unscaled_points.length; i++) {
        if (params.mandelbrot) {
            params.plot_points.push(div(sub(params.unscaled_points[i], params.ccenter), params.cscale));
        } else {
            params.plot_points.push(div(sub(params.unscaled_points[i], params.z0), params.z0Scale));
        }
    }
}

const palette = [
    [1,0,0],
    [0,1,0],
    [1,1,0],
    [0,0,1],
    [1,0,1],
    [0,1,1],
    [1,0.5,0],
    [0.7,0.5,1],
    [1,0,0],
]

function start() {
    glStuff = setup();
    update_buttons();
    if (showDots) {
        gen_mandelbrot_dots2();
    }
    paint();
}

window.onload = start;
    </script>
    <style>
button {
    padding: 10px;
}
button.active {
    background: #ffaaaa;
}
    </style>
</head>
<body>
    <button id="button_zoom" onclick="params.drag='zoom'; update_buttons()">Zoom</button>
    <button id="button_distort" onclick="params.drag='distort'; update_buttons()">Distort</button>
    <br>
    <canvas id="canvas" width="2000" height="1400" onmousedown="mousedown()" onmousemove="mousemove()" onwheel="mousewheel()"></canvas>
</body>
</html>