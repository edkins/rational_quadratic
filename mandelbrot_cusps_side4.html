<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

const NUMERATOR = 9;
const NUMERATOR2 = 10;
const DENOMINATOR = 31;
const PERIOD = Math.round(Math.log2(DENOMINATOR+1));

const showDots = true;
const uPowersArrays = {
    1: [0,1],
    2: [0,0,1],
    3: [0,-1,1,1],
    4: [0,0,-1,1,1],
    5: [0,-1,0,1,1,1],
}

let params = {
    ccenter: [-0.5, 0.0],
    cscale: [2.5, 0.0],

    c: [0.0, 0.0],
    c2: [0.0, 0.0],
    z0: [0.0, 0.0],
    z0Scale: [1.1, 0.0],
    mandelbrot: true,

    color: true,
    drag: "zoom",
    drag_start: [0.0, 0.0],
    timer: null,
    last_moved: 0,
    high_count: 0,
    touchStartA: null,
    touchStartB: null,
    touchStartAScale: null,
    touchStartBScale: null,
    touchSide: null,
    touchStartId: null,
    plot_points: [],
    plot_colors: [],
    unscaled_points: [],
    plot_indices: [],

    pathway: [],
    pathway2: [],

    frac: {num:0,denom:7}
    // frac: binfrac("","000111")
};
let glStuff = null;
let touches = new Map();

function binfrac(fixed, recurring) {
    let num = 0;
    if (fixed !== "") {
        num = parseInt(fixed, 2);
    }
    let denom = Math.pow(2, fixed.length);

    if (recurring !== undefined && recurring !== "") {
        let pot = Math.pow(2, recurring.length);
        num = num * (pot - 1) + parseInt(recurring, 2);
        denom *= pot - 1;
    }

    console.log("binfrac",num,denom);
    return {num, denom};
}

function fragmentShaderSource(max_iter, max_period) {
    return `
        precision highp float;
        varying vec2 c;
        uniform vec2 uc2;
        varying vec2 z0;
        uniform bool uMandelbrot;
        uniform float uBailout;
        uniform float uFracNum;
        uniform float uFracDenom;
        uniform vec3 uPalette[${palette.length}];
        const vec2 one = vec2(1.0, 0.0);

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 csquare(vec2 z) {
            return vec2(
                z.x * z.x - z.y * z.y,
                2.0 * z.x * z.y
            );
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        vec2 csqrt(vec2 z) {
            float r = length(z);
            float theta = atan(z.y, z.x);
            return vec2(
                sqrt(r) * cos(theta / 2.0),
                sqrt(r) * sin(theta / 2.0)
            );
        }

        vec2 other_csqrt(vec2 z) {
            float r = sqrt(length(z));
            float theta = atan(-z.y, -z.x);
            return vec2(
                -r * sin(theta / 2.0),
                r * cos(theta / 2.0)
            );
        }

        float angle_distance(float a, float b) {
            float twopi = 6.28318530718;
            float diff = mod(b - a, twopi);
            return min(diff, twopi - diff);
        }

        float closest_half_angle(float theta, float target) {
            float c0 = theta * 0.5;
            float c1 = c0 + 3.14159265359;
            float d0 = angle_distance(c0, target);
            float d1 = angle_distance(c1, target);
            return d0 < d1 ? c0 : c1;
        }

        float closest_angle(float c0, float c1, float target) {
            float d0 = angle_distance(c0, target);
            float d1 = angle_distance(c1, target);
            return d0 < d1 ? c0 : c1;
        }

        float atan2(vec2 z) {
            return atan(z.y, z.x);
        }

        vec2 cexp(vec2 z) {
            return exp(z.x) * vec2(cos(z.y), sin(z.y));
        }

        vec2 clog(vec2 z) {
            return vec2(log(length(z)), atan(z.y, z.x));
        }

        vec2 cpow(vec2 z, int p) {
            float r = pow(length(z), float(p));
            float theta = atan(z.y, z.x) * float(p);
            return vec2(
                r * cos(theta),
                r * sin(theta)
            );
        }

        float mandelbrot(vec2 actual_z0, vec2 actual_c) {
            vec2 z = actual_z0;
            int escaped = -1;
            for (int iteration = 1; iteration < ${max_iter}; iteration++) {
                z = csquare(z) + actual_c;
                if (length(z) > uBailout) {
                    escaped = iteration;
                    break;
                }
            }

            return log(float(escaped)) / 15.0;
        }

        void main(void) {
            if (uMandelbrot) {
                float fiter = mandelbrot(vec2(0.0, 0.0), c);
                gl_FragColor = vec4(fiter, fiter, fiter, 1.0);
            } else {
                gl_FragColor = vec4(mandelbrot(z0, c), mandelbrot(z0, uc2), 0.5, 1.0);
            }
        }
    `;
}
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.9, 0.9, 1.0);

    // Mandelbrot vertex shader program
    const vsSource = `
        precision highp float;
        attribute vec2 aVertexPosition;
        uniform vec2 uz0;
        uniform vec2 uz0Scale;
        uniform vec2 uc;
        uniform vec2 ucscale;
        uniform vec2 uNudge;
        varying vec2 c;
        varying vec2 z0;
        uniform vec2 aspect;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vec2 vp = aVertexPosition * aspect + uNudge;
            c = uc + mul(vp, ucscale);
            z0 = uz0 + mul(vp, uz0Scale);
        }
    `;

    // Mandelbrot/Julia fragment shader program
    const fsSource = fragmentShaderSource(500, 32);
    const fsSourceHigh = fragmentShaderSource(50000, 100);

    // Initialize shaders
    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);

    // Initialize shaders (high iteration count)
    const fragmentShaderHigh = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderHigh, fsSourceHigh);
    ctx.compileShader(fragmentShaderHigh);
    if (!ctx.getShaderParameter(fragmentShaderHigh, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the high iteration shader: " +
            ctx.getShaderInfoLog(fragmentShaderHigh));
        return null;
    }
    const shaderProgramHigh = ctx.createProgram();
    ctx.attachShader(shaderProgramHigh, vertexShader);
    ctx.attachShader(shaderProgramHigh, fragmentShaderHigh);
    ctx.linkProgram(shaderProgramHigh);

    // Shaders for texture blitting
    const vsSourceBlit = `
        attribute vec2 aVertexPosition;
        varying vec2 vTexCoord;
        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vTexCoord = (aVertexPosition + vec2(1.0, 1.0)) * 0.5;
        }
    `;
    const fsSourceBlit = `
        precision highp float;
        varying vec2 vTexCoord;
        uniform sampler2D uTexture;
        void main(void) {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;
    const vertexShaderBlit = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderBlit, vsSourceBlit);
    ctx.compileShader(vertexShaderBlit);
    const fragmentShaderBlit = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderBlit, fsSourceBlit);
    ctx.compileShader(fragmentShaderBlit);
    if (!ctx.getShaderParameter(vertexShaderBlit, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderBlit, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the blit shaders: " +
            ctx.getShaderInfoLog(vertexShaderBlit) + " " +
            ctx.getShaderInfoLog(fragmentShaderBlit));
        return null;
    }
    const shaderProgramBlit = ctx.createProgram();
    ctx.attachShader(shaderProgramBlit, vertexShaderBlit);
    ctx.attachShader(shaderProgramBlit, fragmentShaderBlit);
    ctx.linkProgram(shaderProgramBlit);

    // Shaders for point markers
    const vsSourcePoint = `
        precision highp float;
        attribute vec2 aVertexPosition;
        attribute vec3 aVertexColor;
        uniform float uPointSize;
        uniform vec2 aspect;
        varying vec3 vertexColor;
        void main(void) {
            gl_Position = vec4(aVertexPosition / aspect, 0.0, 1.0);
            gl_PointSize = uPointSize;
            vertexColor = aVertexColor;
        }
    `;
    const fsSourcePoint = `
        precision highp float;
        varying vec3 vertexColor;
        void main(void) {
            gl_FragColor = vec4(vertexColor, 1.0);
        }
    `;
    const vertexShaderPoint = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderPoint, vsSourcePoint);
    ctx.compileShader(vertexShaderPoint);
    const fragmentShaderPoint = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderPoint, fsSourcePoint);
    ctx.compileShader(fragmentShaderPoint);
    if (!ctx.getShaderParameter(vertexShaderPoint, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderPoint, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the point shaders: " +
            ctx.getShaderInfoLog(vertexShaderPoint) + " " +
            ctx.getShaderInfoLog(fragmentShaderPoint));
        return null;
    }
    const shaderProgramPoint = ctx.createProgram();
    ctx.attachShader(shaderProgramPoint, vertexShaderPoint);
    ctx.attachShader(shaderProgramPoint, fragmentShaderPoint);
    ctx.linkProgram(shaderProgramPoint);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    // Create texture to hold low-iteration Mandelbrot image
    const fbWidth = ctx.canvas.width;
    const fbHeight = ctx.canvas.height;
    const destTexture = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTexture);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidth, fbHeight, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render low-iteration Mandelbrot image into
    const framebuffer = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffer);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTexture, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    // Create texture to hold high-iteration Mandelbrot image
    const fbWidthHigh = fbWidth;
    const fbHeightHigh = fbHeight;
    const destTextureHigh = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTextureHigh);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidthHigh, fbHeightHigh, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render high-iteration Mandelbrot image into
    const framebufferHigh = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebufferHigh);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTextureHigh, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    // Create vertex buffer to hold points
    const pointVertexBuffer = ctx.createBuffer();
    const pointColorBuffer = ctx.createBuffer();
    const pointIndexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, pointVertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, [], ctx.DYNAMIC_DRAW);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, pointColorBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, [], ctx.DYNAMIC_DRAW);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, null);

    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, pointIndexBuffer);
    ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, [], ctx.DYNAMIC_DRAW);
    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);

    return {
        main: {
            shaderProgram,
            aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgram, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgram, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgram, "uz0Scale"),
            uc: ctx.getUniformLocation(shaderProgram, "uc"),
            uc2: ctx.getUniformLocation(shaderProgram, "uc2"),
            ucscale: ctx.getUniformLocation(shaderProgram, "ucscale"),
            uBailout: ctx.getUniformLocation(shaderProgram, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgram, "uBailin"),
            bailin: 0.002,
            bailout: 1000000,
            uNudge: ctx.getUniformLocation(shaderProgram, "uNudge"),
            vertexBuffer,
            destTexture,
            framebuffer,
            fbWidth,
            fbHeight,
            uBrightness: ctx.getUniformLocation(shaderProgram, "uBrightness"),
            brightness: 0.02,
            uAspect: ctx.getUniformLocation(shaderProgram, "aspect"),
            uFracNum: ctx.getUniformLocation(shaderProgram, "uFracNum"),
            uFracDenom: ctx.getUniformLocation(shaderProgram, "uFracDenom"),
            uPowers: ctx.getUniformLocation(shaderProgram, "uPowers"),
            uPalette: ctx.getUniformLocation(shaderProgram, "uPalette"),
        },
        high: {
            shaderProgram: shaderProgramHigh,
            aVertexPosition: ctx.getAttribLocation(shaderProgramHigh, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgramHigh, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgramHigh, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgramHigh, "uz0Scale"),
            uc: ctx.getUniformLocation(shaderProgramHigh, "uc"),
            uc2: ctx.getUniformLocation(shaderProgramHigh, "uc2"),
            uascale: ctx.getUniformLocation(shaderProgramHigh, "uascale"),
            ucscale: ctx.getUniformLocation(shaderProgramHigh, "ucscale"),
            uBailout: ctx.getUniformLocation(shaderProgramHigh, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgramHigh, "uBailin"),
            bailin: 0.001,
            bailout: 1000000,
            uNudge: ctx.getUniformLocation(shaderProgramHigh, "uNudge"),
            vertexBuffer,
            destTexture: destTextureHigh,
            framebuffer: framebufferHigh,
            fbWidth: fbWidthHigh,
            fbHeight: fbHeightHigh,
            uBrightness: ctx.getUniformLocation(shaderProgramHigh, "uBrightness"),
            brightness: 0.02,
            uAspect: ctx.getUniformLocation(shaderProgramHigh, "aspect"),
            uFracNum: ctx.getUniformLocation(shaderProgramHigh, "uFracNum"),
            uFracDenom: ctx.getUniformLocation(shaderProgramHigh, "uFracDenom"),
            uPowers: ctx.getUniformLocation(shaderProgramHigh, "uPowers"),
            uPalette: ctx.getUniformLocation(shaderProgramHigh, "uPalette"),
        },
        blit: {
            shaderProgram: shaderProgramBlit,
            aVertexPosition: ctx.getAttribLocation(shaderProgramBlit, "aVertexPosition"),
            uTexture: ctx.getUniformLocation(shaderProgramBlit, "uTexture"),
            vertexBuffer,
        },
        point: {
            shaderProgram: shaderProgramPoint,
            uPointSize: ctx.getUniformLocation(shaderProgramPoint, "uPointSize"),
            uAspect: ctx.getUniformLocation(shaderProgramPoint, "aspect"),
            pointVertexBuffer,
            pointColorBuffer,
            pointIndexBuffer,
            aVertexPosition: ctx.getAttribLocation(shaderProgramPoint, "aVertexPosition"),
            aVertexColor: ctx.getAttribLocation(shaderProgramPoint, "aVertexColor"),
        }
    };
}

function paintMandelbrot(ctx, stuff, nudgeX, nudgeY) {
    // Draw the Julia or Mandelbrot set
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform1f(stuff.uBailout, stuff.bailout);
    ctx.uniform2f(stuff.uNudge, nudgeX, nudgeY);
    ctx.uniform2f(stuff.uAspect, ctx.canvas.width / Math.min(ctx.canvas.width, ctx.canvas.height), ctx.canvas.height / Math.min(ctx.canvas.width, ctx.canvas.height));
    ctx.uniform1f(stuff.uFracNum, params.frac.num);
    ctx.uniform1f(stuff.uFracDenom, params.frac.denom);

    // ctx.uniform1iv(stuff.uPowers, uPowersArrays[B]);
    const paletteConcat = [];
    for (let i = 0; i < palette.length; i++) {
        paletteConcat.push(...palette[i]);
    }
    ctx.uniform3fv(stuff.uPalette, paletteConcat);

    if (params.mandelbrot) {
        ctx.uniform1i(stuff.uMandelbrot, true);
        ctx.uniform2f(stuff.uz0Scale, 0.0, 0.0);
        ctx.uniform2f(stuff.uc, params.ccenter[0], params.ccenter[1]);
        ctx.uniform2f(stuff.ucscale, params.cscale[0], params.cscale[1]);
    } else {
        ctx.uniform1i(stuff.uMandelbrot, false);
        ctx.uniform2f(stuff.uz0Scale, params.z0Scale[0], params.z0Scale[1]);
        ctx.uniform2f(stuff.uc, params.c[0], params.c[1]);
        ctx.uniform2f(stuff.uc2, params.c2[0], params.c2[1]);
        ctx.uniform2f(stuff.ucscale, 0.0, 0.0);
        ctx.uniform2f(stuff.uz0, params.z0[0], params.z0[1]);
    }
    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
}

function blit_texture(ctx, stuff, texture) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.activeTexture(ctx.TEXTURE0);
    ctx.bindTexture(ctx.TEXTURE_2D, texture);
    ctx.uniform1i(stuff.uTexture, 0);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);

    ctx.bindTexture(ctx.TEXTURE_2D, null);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
}

function draw_dots(ctx, stuff) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform1f(stuff.uPointSize, 4.0);
    ctx.uniform2f(stuff.uAspect, ctx.canvas.width / Math.min(ctx.canvas.width, ctx.canvas.height), ctx.canvas.height / Math.min(ctx.canvas.width, ctx.canvas.height));

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.pointVertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.pointColorBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexColor);
    ctx.vertexAttribPointer(stuff.aVertexColor, 3, ctx.FLOAT, false, 0, 0);

    if (params.mandelbrot) {
        ctx.drawArrays(ctx.POINTS, 0, params.plot_points.length);
    } else {
        ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, stuff.pointIndexBuffer);
        ctx.drawElements(ctx.LINES, params.plot_indices.length, ctx.UNSIGNED_SHORT, 0);
        ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
        ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
    }
}

function paintDots() {
    const ctx = document.getElementById("canvas").getContext("webgl");
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
    ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
    if (params.high_count <= 1) {
        blit_texture(ctx, glStuff.blit, glStuff.main.destTexture);
    } else {
        blit_texture(ctx, glStuff.blit, glStuff.high.destTexture);
    }
    draw_dots(ctx, glStuff.point);
}

function paint() {
    const ctx = document.getElementById("canvas").getContext("webgl");
    if (params.high_count === 0) {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.main.framebuffer);
        ctx.viewport(0, 0, glStuff.main.fbWidth, glStuff.main.fbHeight);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        paintMandelbrot(ctx, glStuff.main, 0, 0);

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        blit_texture(ctx, glStuff.blit, glStuff.main.destTexture);
        draw_dots(ctx, glStuff.point);

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        params.high_count += 1;
        params.timer = setTimeout(paint, 300);
    } else {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.high.framebuffer);
        ctx.viewport(0, 0, glStuff.high.fbWidth, glStuff.high.fbHeight);

        if (params.high_count === 1) {
            ctx.clear(ctx.COLOR_BUFFER_BIT);
            paintMandelbrot(ctx, glStuff.high, 0, 0);
        } else {
            ctx.enable(ctx.BLEND);
            ctx.blendEquation(ctx.FUNC_ADD);
            ctx.blendFuncSeparate(ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA, ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA);
            ctx.blendColor(1.0, 1.0, 1.0, 1.0 / params.high_count);
            let nudgeX = (Math.random() - 0.5) * 0.5 / 100;
            let nudgeY = (Math.random() - 0.5) * 0.5 / 100;
            paintMandelbrot(ctx, glStuff.high, nudgeX, nudgeY);
            ctx.disable(ctx.BLEND);
        }

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        blit_texture(ctx, glStuff.blit, glStuff.high.destTexture);
        draw_dots(ctx, glStuff.point);

        params.high_count += 1;

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        if (params.high_count < 1) {
            params.timer = setTimeout(paint, 100);
        }
    }
}

function mousedown() {
}

function mousemove() {
    const x = event.clientX;
    const y = event.clientY;
    const originX = event.target.getBoundingClientRect().left;
    const originY = event.target.getBoundingClientRect().top;
    const hwidth = event.target.clientWidth / 2;
    const hheight = event.target.clientHeight / 2;
    const aspectX = event.target.clientWidth / Math.min(event.target.clientWidth, event.target.clientHeight);
    const aspectY = event.target.clientHeight / Math.min(event.target.clientWidth, event.target.clientHeight);
    const xy = [
        ((x - originX - hwidth) / hwidth) * aspectX,
        (-(y - originY - hheight) / hheight) * aspectY
    ];
    if (event.buttons === 1) {
        let param = (x - originX) * 0.5 / hwidth;
        let index = Math.min(params.pathway.length-1, Math.max(0, param * params.pathway.length));
        params.c = params.pathway[index];
        params.c2 = params.pathway2[index];
        params.mandelbrot = false;
        params.unscaled_points = [];
        params.plot_colors = [];
        params.plot_points = [];
        params.unscaled_points = [];
        params.plot_colors = [];
        params.plot_indices = [];
        add_julia_dots([0,0], params.c, [1,0,0]);
        add_julia_dots([0,0], params.c2, [0,1,0]);
        scale_mandelbrot_dots();
        repaint();
    } else if (event.shiftKey && !params.mandelbrot) {
        params.unscaled_points = [];
        params.plot_colors = [];
        params.plot_indices = [];
        const start_z = add(params.z0, mul(params.z0Scale, xy));
        add_julia_dots(start_z, params.c, [1,0,0]);
        add_julia_dots(start_z, params.c2, [0,1,0]);
        scale_mandelbrot_dots();
        paintDots();
    }
}

function add_julia_dots(start_z, c, color) {
    let z = start_z;
    for (let i = 0; i < 5000; i++) {
        params.unscaled_points.push(z);
        params.plot_colors.push(color);
        if (i >= PERIOD) {
            params.plot_indices.push(params.unscaled_points.length-1-PERIOD);
            params.plot_indices.push(params.unscaled_points.length-1);
        }
        z = add(mul(z,z), c);
        if (cnorm(z) > 16) {
            break;
        }
    }
}

function mousewheel() {
    event.preventDefault();
    const x = event.clientX;
    const y = event.clientY;
    const originX = event.target.getBoundingClientRect().left;
    const originY = event.target.getBoundingClientRect().top;
    const hwidth = event.target.clientWidth / 2;
    const hheight = event.target.clientHeight / 2;
    const aspectX = event.target.clientWidth / Math.min(event.target.clientWidth, event.target.clientHeight);
    const aspectY = event.target.clientHeight / Math.min(event.target.clientWidth, event.target.clientHeight);
    let sc = Math.pow(1.001, event.deltaY);
    const xy = [
        ((x - originX - hwidth) / hwidth) * aspectX,
        (-(y - originY - hheight) / hheight) * aspectY
    ];
    if (params.mandelbrot) {
        params.ccenter = add(params.ccenter, scale((1 - sc) * 1.2, mul(xy, params.cscale)));
        params.cscale[0] *= sc;
        params.cscale[1] *= sc;
    } else {
        params.z0 = add(params.z0, scale((1 - sc) * 1.2, mul(xy, params.z0Scale)));
        params.z0Scale = scale(sc, params.z0Scale);

    }
    scale_mandelbrot_dots();
    repaint();
}

function touchstart() {
    event.preventDefault();
    for (const changedTouch of event.changedTouches) {
        if (touches.size === 0) {
            const offsetX = event.target.getBoundingClientRect().left;
            const offsetY = event.target.getBoundingClientRect().top;
            const x = (changedTouch.pageX - offsetX) / 200 - 1;
            const y = -(changedTouch.pageY - offsetY) / 200 + 2;

            const aVal = add(params.a, mul([x, y], params.ascale));
            const bVal = add(params.b, mul([x, y], params.bscale));
            const cVal = sub([1.0, 0.0], add(aVal, bVal));
            if (aVal > bVal && aVal > cVal) {
                params.touchSide = "a";
            } else if (bVal > cVal) {
                params.touchSide = "b";
            } else {
                params.touchSide = "c";
            }
            params.touchStartId = changedTouch.identifier;
        }

        const touch = {
            pageX: changedTouch.pageX,
            pageY: changedTouch.pageY,
            // startX: changedTouch.pageX,
            // startY: changedTouch.pageY,
            identifier: changedTouch.identifier,
        };

        touches.set(changedTouch.identifier, touch);
    }

    params.touchStartA = [params.a[0], params.a[1]];
    params.touchStartB = [params.b[0], params.b[1]];
    params.touchStartAScale = [params.ascale[0], params.ascale[1]];
    params.touchStartBScale = [params.bscale[0], params.bscale[1]];
    for (const touch of touches.values()) {
        touch.startX = touch.pageX;
        touch.startY = touch.pageY;
    }
}

function touchend() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];
    const ongoingTouch = touches.get(changedTouch.identifier);
    const deltaX = changedTouch.pageX - ongoingTouch.pageX;
    const deltaY = changedTouch.pageY - ongoingTouch.pageY;
    touches.delete(changedTouch.identifier);
}

function add(x, y) {
    return [
        x[0] + y[0],
        x[1] + y[1]
    ];
}

function add3(x, y, z) {
    return [
        x[0] + y[0] + z[0],
        x[1] + y[1] + z[1]
    ];
}

function add4(x, y, z, w) {
    return [
        x[0] + y[0] + z[0] + w[0],
        x[1] + y[1] + z[1] + w[1]
    ];
}

function sub(x, y) {
    return [
        x[0] - y[0],
        x[1] - y[1]
    ];
}

function mul(x, y) {
    return [
        x[0] * y[0] - x[1] * y[1],
        x[0] * y[1] + x[1] * y[0]
    ];
}

function div(x, y) {
    const denom = y[0] * y[0] + y[1] * y[1];
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function divEpsilon(x, y, epsilon) {
    const denom = y[0] * y[0] + y[1] * y[1] + epsilon;
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function recip(z) {
    return div([1.0,0.0], z);
}

function scale(r, c) {
    return [
        r * c[0],
        r * c[1]
    ];
}

function cnorm(c) {
    return Math.hypot(c[0], c[1]);
}

function cnorm_squared(c) {
    return c[0] * c[0] + c[1] * c[1];
}

function touchmove() {
    event.preventDefault();
    for (let i = 0; i < event.changedTouches.length; i++) {
        const changedTouch = event.changedTouches[i];
        const ongoingTouch = touches.get(changedTouch.identifier);
        if (ongoingTouch) {
            ongoingTouch.pageX = changedTouch.pageX;
            ongoingTouch.pageY = changedTouch.pageY;
        }
    }

    if (touches.size === 1) {
        const offsetX = event.target.getBoundingClientRect().left;
        const offsetY = event.target.getBoundingClientRect().top;

        const touch0 = touches.get(params.touchStartId);
        if (!touch0) {
            return;
        }
        let x = (touch0.pageX - touch0.startX) / 200;
        let y = -(touch0.pageY - touch0.startY) / 200;

        let ascaled = mul(params.touchStartAScale, [x,y]);
        let bscaled = mul(params.touchStartBScale, [x,y]);
        if (params.drag === "zoom") {
            params.a = sub(params.touchStartA, ascaled);
            params.b = sub(params.touchStartB, bscaled);
        } else if (params.drag === "distort") {
            params.a[1] = params.touchStartA[1] - ascaled[1];
            params.b[1] = params.touchStartB[1] - bscaled[1];
        }

        // params.ascale[1] = params.touchStartAScale[1] - ascaled[1];
        // params.bscale[1] = params.touchStartBScale[1] - bscaled[1];

        repaint();
    }
    
    if (touches.size === 2) {
        const touch0 = touches.get(params.touchStartId);
        const touch1 = Array.from(touches.values()).find(t => t.identifier !== params.touchStartId);
        if (!touch0 || !touch1) {
            return;
        }

        let x0 = (touch0.pageX - touch0.startX) / 200;
        let y0 = -(touch0.pageY - touch0.startY) / 200;

        let x1 = (touch1.pageX - touch1.startX) / 200;
        let y1 = -(touch1.pageY - touch1.startY) / 200;

        let startd = [
            touch1.startX - touch0.startX,
            -(touch1.startY - touch0.startY)
        ];
        let endd = [
            touch1.pageX - touch0.pageX,
            -(touch1.pageY - touch0.pageY)
        ];
        let rotate = div(startd, endd);

        let ascaled = mul(params.touchStartAScale, [x0,y0]);
        let bscaled = mul(params.touchStartBScale, [x0,y0]);
        if (params.drag === "zoom") {
            params.a = sub(params.touchStartA, ascaled);
            params.b = sub(params.touchStartB, bscaled);
            params.ascale = mul(params.touchStartAScale, rotate);
            params.bscale = mul(params.touchStartBScale, rotate);
        }
        repaint();
    }
}

function repaint() {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    paint();
}

function scale_rotate(scaleX, scaleY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.mandelbrot) {
        if (params.drag === "ca") {
            let c0 = -params.ascale[0] - params.bscale[0];
            let c1 = -params.ascale[1] - params.bscale[1];
            let cincrx = c0 * scaleX - c1 * scaleY - c0;
            let cincry = c0 * scaleY + c1 * scaleX - c1;
            params.ascale[0] -= cincrx;
            params.ascale[1] -= cincry;
        }
        if (params.drag === "bc") {
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
        if (params.drag === "ab") {
            let aincrx = params.ascale[0] * scaleX - params.ascale[1] * scaleY - params.ascale[0];
            let aincry = params.ascale[0] * scaleY + params.ascale[1] * scaleX - params.ascale[1];
            params.ascale[0] += aincrx;
            params.ascale[1] += aincry;
            params.bscale[0] -= aincrx;
            params.bscale[1] -= aincry;
        }
        if (params.drag === "all") {
            params.ascale = [
                params.ascale[0] * scaleX - params.ascale[1] * scaleY,
                params.ascale[0] * scaleY + params.ascale[1] * scaleX
            ];
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
    } else {
        params.z0Scale /= scale;
    }
}

function move(deltaX, deltaY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.drag === "ca") {
        const cscale = [
            (scale[0] + params.bscale[0]),
            (params.ascale[1] + params.bscale[1])
        ];
        params.a[0] += deltaX * cscale[0] - deltaY * cscale[1];
        params.a[1] += deltaY * cscale[0] + deltaX * cscale[1];
    }
    if (params.drag === "bc") {
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
    if (params.drag === "ab") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] -= deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.b[1] -= deltaY * params.ascale[0] + deltaX * params.ascale[1];
    }
    if (params.drag === "all") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
}

function csqrt(z) {
    const r = Math.sqrt(cnorm(z));
    const theta = Math.atan2(z[1], z[0]);
    return [
        r * Math.cos(theta / 2.0),
        r * Math.sin(theta / 2.0)
    ];
}

function other_csqrt(z) {
    const r = Math.sqrt(cnorm(z));
    const theta = Math.atan2(-z[1], -z[0]);
    return [
        -r * Math.sin(theta / 2.0),
        r * Math.cos(theta / 2.0)
    ];
}

function solve_quadratic(a, b, c) {
    const discriminant = csqrt(sub(mul(b, b), scale(4.0, mul(a, c))));
    const root1 = div(sub(discriminant, b), scale(2.0, a));
    return root1;
}

class Derivatives {
    constructor(value, dz, dc) {
        this.value = value;
        this.dz = dz;
        this.dc = dc;
    }

    static fromConstant(value) {
        const z = [0.0, 0.0];
        return new Derivatives(value, z, z);
    }

    static fromRealConstant(value) {
        return Derivatives.fromConstant([value, 0.0]);
    }

    static fromZ(z) {
        const one = [1.0, 0.0];
        const zero = [0.0, 0.0];
        return new Derivatives(z, one, zero);
    }

    static fromC(p) {
        const one = [1.0, 0.0];
        const zero = [0.0, 0.0];
        return new Derivatives(p, zero, one);
    }

    add(other) {
        return new Derivatives(
            add(this.value, other.value),
            add(this.dz, other.dz),
            add(this.dc, other.dc)
        );
    }

    sub(other) {
        return new Derivatives(
            sub(this.value, other.value),
            sub(this.dz, other.dz),
            sub(this.dc, other.dc)
        );
    }

    scale(r) {
        return new Derivatives(
            scale(r, this.value),
            scale(r, this.dz),
            scale(r, this.dc)
        );
    }

    mul(other) {
        return new Derivatives(
            mul(this.value, other.value),
            add(
                mul(this.dz, other.value),
                mul(this.value, other.dz)
            ),
            add(
                mul(this.dc, other.value),
                mul(this.value, other.dc)
            )
        );
    }

    recip() {
        const f = div([1.0, 0.0], this.value);
        const f1 = scale(-1, mul(f, f));
        return new Derivatives(
            f,
            mul(f1, this.dz),
            mul(f1, this.dc)
        );
    }

    square() {
        return this.mul(this);
    }

    div(other) {
        return this.mul(other.recip());
    }
}

function direction_to_go(z) {
    let Z = Derivatives.fromZ(z);
    let C = Derivatives.fromC(params.c);
    for (let i = 0; i < 1000; i++) {
        Z = Z.square().add(C);
        if (cnorm(Z.value) > 1000) {
            break;
        }
    }
    return div(Z.value, Z.dz);
}

function gen_dots() {
    let c = params.c;
    let z = c;
    let prev = [0,0];

    params.plot_points = [];
    for (let i = 0; i < 500; i++) {
        let d = direction_to_go(z);
        z = add(z, scale(1, d));
        // let preimage = csqrt(sub(z, c));
        // if (cnorm(sub(prev,preimage)) > cnorm(add(prev,preimage))) {
        //     preimage = scale(-1, preimage);
        // }
        // prev = preimage;
        params.plot_points.push(div(sub(z, params.z0), params.z0Scale));
        if (cnorm(z) > 1000) {
            break;
        }
    }
}

function mandelbrot_direction_to_go(c,target,target_iter) {
    let Z = Derivatives.fromZ(c);
    Z.dc = [1,0];
    let C = Derivatives.fromC(c);
    for (let i = 0; i < target_iter; i++) {
        Z = Z.square().add(C);
    }
    return {d:divEpsilon(sub(Z.value, target), Z.dc, 0.0001), warning:cnorm(Z.value) > 1000};
}

function scale_mandelbrot_dots() {
    params.plot_points = [];
    for (let i = 0; i < params.unscaled_points.length; i++) {
        if (params.mandelbrot) {
            params.plot_points.push(div(sub(params.unscaled_points[i], params.ccenter), params.cscale));
        } else {
            params.plot_points.push(div(sub(params.unscaled_points[i], params.z0), params.z0Scale));
        }
    }
    const ctx = canvas.getContext("webgl");

    const pdata = [];
    const cdata = [];
    for (let i = 0; i < params.plot_points.length; i++) {
        pdata.push(...params.plot_points[i]);
        cdata.push(...params.plot_colors[i]);
    }

    ctx.bindBuffer(ctx.ARRAY_BUFFER, glStuff.point.pointVertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array(pdata), ctx.DYNAMIC_DRAW);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, glStuff.point.pointColorBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array(cdata), ctx.DYNAMIC_DRAW);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, null);

    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, glStuff.point.pointIndexBuffer);
    ctx.bufferData(ctx.ELEMENT_ARRAY_BUFFER, new Uint16Array(params.plot_indices), ctx.DYNAMIC_DRAW);
    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
}

const palette = [
    [1,0,0],
    [0,1,0],
    [1,1,0],
    [0,0,1],
    [1,0,1],
    [0,1,1],
    [1,0.5,0],
    [0.7,0.5,1],
    [1,0,0],
]

function gen_mandelbrot_dots() {
    let theta = 0;
    params.unscaled_points = [];
    let done = [];

    params.pathway = [];

    let denom = DENOMINATOR;
    for (let num of [NUMERATOR,NUMERATOR2]) {
        if (done.indexOf(num / denom) !== -1) {
            continue;
        }
        done.push(num / denom);
        let target_ang = num;
        let target_lens = [];
        for (let i = 0; i < 10; i++) {
            target_lens[i] = Math.exp(Math.log(1e3) * Math.pow(2, i/10));
        }
        let target_len = target_lens.length - 1;
        let c = scale(target_lens[target_len], [Math.cos(6.28318530718 * target_ang / denom),Math.sin(6.28318530718 * target_ang / denom)]);
        let target_iter = 0;
        for (let i = 0; i < 4000; i++) {
            let target = scale(target_lens[target_len], [Math.cos(6.28318530718 * target_ang / denom),Math.sin(6.28318530718 * target_ang / denom)]);
            let {d,warning} = mandelbrot_direction_to_go(c,target,target_iter);
            c = sub(c, d);
            target_len -= 1;
            if (target_len < 0) {
                target_len = target_lens.length - 1;
                target_ang = (target_ang * 2) % denom;
                target_iter += 1;
            }
            if (true) {
                params.unscaled_points.push(c);
                params.plot_colors.push((num === NUMERATOR) ? [1,0,0] : [0,1,0]);
                if (num === NUMERATOR) {
                    params.pathway.push(c);
                } else if (num === NUMERATOR2) {
                    params.pathway2.push(c);
                }
            }
        }
    }
    scale_mandelbrot_dots();
}

function start() {
    glStuff = setup();
    if (showDots) {
        gen_mandelbrot_dots();
    }
    paint();
}

window.onload = start;
    </script>
    <style>
button {
    padding: 10px;
}
button.active {
    background: #ffaaaa;
}
    </style>
</head>
<body>
    <br>
    <canvas id="canvas" width="2000" height="1400" onmousedown="mousedown()" onmousemove="mousemove()" onwheel="mousewheel()"></canvas>
</body>
</html>