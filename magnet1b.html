<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

let params = {
    ccenter: [0.25, 0.0],
    cscale: [2.5, 0.0],

    c: [-0.0, 0.0],
    z0: [0.0, 0.0],
    z0Scale: [2.0, 0.0],
    mandelbrot: true,

    color: true,
    drag: "zoom",
    drag_start: [0.0, 0.0],
    timer: null,
    last_moved: 0,
    high_count: 0,
    touchStartA: null,
    touchStartB: null,
    touchStartAScale: null,
    touchStartBScale: null,
    touchSide: null,
    touchStartId: null,
    plot_points: [],
};
let glStuff = null;
let touches = new Map();

function fragmentShaderSource(max_iter, max_period) {
    return `
        precision highp float;
        varying vec2 c;
        varying vec2 z0;
        uniform bool uMandelbrot;
        uniform float uBailout;
        const vec2 one = vec2(1.0, 0.0);

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        float angle_distance(float a, float b) {
            float twopi = 6.28318530718;
            float diff = mod(b - a, twopi);
            return min(diff, twopi - diff);
        }

        vec4 mandelbrot(vec2 actual_z0) {
            vec2 z = actual_z0;
            float theta = atan(z.y, z.x);
            bool flip = true;
            float add = 0.0;
            float remember = 0.0;
            for (int iteration = 0; iteration < ${max_period}; iteration++) {
                float fiter = float(iteration);
                vec2 z2 = mul(z, z);
                if (!flip) {
                    float p = 3.1415926535 * pow(0.5, 0.5 * (fiter - 1.0));
                    if (z.x < 0.0) {
                        add = p;
                        add += remember;
                    }
                    remember += (z.y < 0.0) ? p : 0.0;
                }
                z = div(
                    z2 + c,
                    z2 - one
                );
                float theta2 = atan(z.y, z.x);
                flip = !flip;
                if (flip) {
                    theta /= 2.0;
                    if (angle_distance(theta, theta2) > angle_distance(theta + 3.1415926535, theta2)) {
                        theta += 3.1415926535;
                    }
                }
                if (length(z) > uBailout) {
                    if (flip || iteration <= -1) {
                        return vec4(0.5, 0.5, 0.5, 1.0);
                    }
                    theta = theta2 * pow(0.5, fiter * 0.5);
                    theta += add;
                    return vec4(0.5 + vec2(cos(theta), sin(theta)) * 0.5, 0.0, 1.0);
                }
            }

            return vec4(0.0, 0.0, 0.0, 1.0);
        }

        void main(void) {
            if (uMandelbrot) {
                gl_FragColor = mandelbrot(c);
            } else {
                gl_FragColor = mandelbrot(z0);
            }
        }
    `;
}
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.9, 0.9, 1.0);

    // Mandelbrot vertex shader program
    const vsSource = `
        precision highp float;
        attribute vec2 aVertexPosition;
        uniform vec2 uz0;
        uniform vec2 uz0Scale;
        uniform vec2 uc;
        uniform vec2 ucscale;
        uniform vec2 uNudge;
        varying vec2 c;
        varying vec2 z0;
        uniform vec2 aspect;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vec2 vp = aVertexPosition * aspect + uNudge;
            c = uc + mul(vp, ucscale);
            z0 = uz0 + mul(vp, uz0Scale);
        }
    `;

    // Mandelbrot/Julia fragment shader program
    const fsSource = fragmentShaderSource(200, 32);
    const fsSourceHigh = fragmentShaderSource(2000, 100);

    // Initialize shaders
    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);

    // Initialize shaders (high iteration count)
    const fragmentShaderHigh = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderHigh, fsSourceHigh);
    ctx.compileShader(fragmentShaderHigh);
    if (!ctx.getShaderParameter(fragmentShaderHigh, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the high iteration shader: " +
            ctx.getShaderInfoLog(fragmentShaderHigh));
        return null;
    }
    const shaderProgramHigh = ctx.createProgram();
    ctx.attachShader(shaderProgramHigh, vertexShader);
    ctx.attachShader(shaderProgramHigh, fragmentShaderHigh);
    ctx.linkProgram(shaderProgramHigh);

    // Shaders for texture blitting
    const vsSourceBlit = `
        attribute vec2 aVertexPosition;
        varying vec2 vTexCoord;
        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vTexCoord = (aVertexPosition + vec2(1.0, 1.0)) * 0.5;
        }
    `;
    const fsSourceBlit = `
        precision highp float;
        varying vec2 vTexCoord;
        uniform sampler2D uTexture;
        void main(void) {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;
    const vertexShaderBlit = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderBlit, vsSourceBlit);
    ctx.compileShader(vertexShaderBlit);
    const fragmentShaderBlit = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderBlit, fsSourceBlit);
    ctx.compileShader(fragmentShaderBlit);
    if (!ctx.getShaderParameter(vertexShaderBlit, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderBlit, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the blit shaders: " +
            ctx.getShaderInfoLog(vertexShaderBlit) + " " +
            ctx.getShaderInfoLog(fragmentShaderBlit));
        return null;
    }
    const shaderProgramBlit = ctx.createProgram();
    ctx.attachShader(shaderProgramBlit, vertexShaderBlit);
    ctx.attachShader(shaderProgramBlit, fragmentShaderBlit);
    ctx.linkProgram(shaderProgramBlit);

    // Shaders for point markers
    const vsSourcePoint = `
        precision highp float;
        uniform vec2 uVertexPosition;
        uniform float uPointSize;
        void main(void) {
            gl_Position = vec4(uVertexPosition * vec2(1.0, 0.5), 0.0, 1.0);
            gl_PointSize = uPointSize;
        }
    `;
    const fsSourcePoint = `
        precision highp float;
        uniform vec3 uColor;
        void main(void) {
            gl_FragColor = vec4(uColor, 1.0);
        }
    `;
    const vertexShaderPoint = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderPoint, vsSourcePoint);
    ctx.compileShader(vertexShaderPoint);
    const fragmentShaderPoint = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderPoint, fsSourcePoint);
    ctx.compileShader(fragmentShaderPoint);
    if (!ctx.getShaderParameter(vertexShaderPoint, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderPoint, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the point shaders: " +
            ctx.getShaderInfoLog(vertexShaderPoint) + " " +
            ctx.getShaderInfoLog(fragmentShaderPoint));
        return null;
    }
    const shaderProgramPoint = ctx.createProgram();
    ctx.attachShader(shaderProgramPoint, vertexShaderPoint);
    ctx.attachShader(shaderProgramPoint, fragmentShaderPoint);
    ctx.linkProgram(shaderProgramPoint);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    // Create texture to hold low-iteration Mandelbrot image
    const fbWidth = ctx.canvas.width;
    const fbHeight = ctx.canvas.height;
    const destTexture = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTexture);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidth, fbHeight, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render low-iteration Mandelbrot image into
    const framebuffer = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffer);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTexture, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    // Create texture to hold high-iteration Mandelbrot image
    const fbWidthHigh = fbWidth;
    const fbHeightHigh = fbHeight;
    const destTextureHigh = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTextureHigh);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidthHigh, fbHeightHigh, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render high-iteration Mandelbrot image into
    const framebufferHigh = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebufferHigh);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTextureHigh, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    return {
        main: {
            shaderProgram,
            aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgram, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgram, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgram, "uz0Scale"),
            uc: ctx.getUniformLocation(shaderProgram, "uc"),
            ucscale: ctx.getUniformLocation(shaderProgram, "ucscale"),
            uBailout: ctx.getUniformLocation(shaderProgram, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgram, "uBailin"),
            bailin: 0.002,
            bailout: 10,
            uNudge: ctx.getUniformLocation(shaderProgram, "uNudge"),
            vertexBuffer,
            destTexture,
            framebuffer,
            fbWidth,
            fbHeight,
            uBrightness: ctx.getUniformLocation(shaderProgram, "uBrightness"),
            brightness: 0.02,
            uAspect: ctx.getUniformLocation(shaderProgram, "aspect"),
        },
        high: {
            shaderProgram: shaderProgramHigh,
            aVertexPosition: ctx.getAttribLocation(shaderProgramHigh, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgramHigh, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgramHigh, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgramHigh, "uz0Scale"),
            uc: ctx.getUniformLocation(shaderProgramHigh, "uc"),
            uascale: ctx.getUniformLocation(shaderProgramHigh, "uascale"),
            ucscale: ctx.getUniformLocation(shaderProgramHigh, "ucscale"),
            uBailout: ctx.getUniformLocation(shaderProgramHigh, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgramHigh, "uBailin"),
            bailin: 0.001,
            bailout: 10,
            uNudge: ctx.getUniformLocation(shaderProgramHigh, "uNudge"),
            vertexBuffer,
            destTexture: destTextureHigh,
            framebuffer: framebufferHigh,
            fbWidth: fbWidthHigh,
            fbHeight: fbHeightHigh,
            uBrightness: ctx.getUniformLocation(shaderProgramHigh, "uBrightness"),
            brightness: 0.02,
            uAspect: ctx.getUniformLocation(shaderProgramHigh, "aspect"),
        },
        blit: {
            shaderProgram: shaderProgramBlit,
            aVertexPosition: ctx.getAttribLocation(shaderProgramBlit, "aVertexPosition"),
            uTexture: ctx.getUniformLocation(shaderProgramBlit, "uTexture"),
            vertexBuffer,
        },
        point: {
            shaderProgram: shaderProgramPoint,
            uVertexPosition: ctx.getUniformLocation(shaderProgramPoint, "uVertexPosition"),
            uPointSize: ctx.getUniformLocation(shaderProgramPoint, "uPointSize"),
            uColor: ctx.getUniformLocation(shaderProgramPoint, "uColor"),
        }
    };
}

function paintMandelbrot(ctx, stuff, nudgeX, nudgeY) {
    // Draw the Julia or Mandelbrot set
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform1f(stuff.uBailout, stuff.bailout);
    ctx.uniform2f(stuff.uNudge, nudgeX, nudgeY);
    ctx.uniform2f(stuff.uAspect, ctx.canvas.width / Math.min(ctx.canvas.width, ctx.canvas.height), ctx.canvas.height / Math.min(ctx.canvas.width, ctx.canvas.height));
    if (params.mandelbrot) {
        ctx.uniform1i(stuff.uMandelbrot, true);
        ctx.uniform2f(stuff.uz0Scale, 0.0, 0.0);
        ctx.uniform2f(stuff.uc, params.ccenter[0], params.ccenter[1]);
        ctx.uniform2f(stuff.ucscale, params.cscale[0], params.cscale[1]);
    } else {
        ctx.uniform1i(stuff.uMandelbrot, false);
        ctx.uniform2f(stuff.uz0Scale, params.z0Scale[0], params.z0Scale[1]);
        ctx.uniform2f(stuff.uc, params.c[0], params.c[1]);
        ctx.uniform2f(stuff.ucscale, 0.0, 0.0);
        ctx.uniform2f(stuff.uz0, params.z0[0], params.z0[1]);
    }
    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
}

function blit_texture(ctx, stuff, texture) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.activeTexture(ctx.TEXTURE0);
    ctx.bindTexture(ctx.TEXTURE_2D, texture);
    ctx.uniform1i(stuff.uTexture, 0);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);

    ctx.bindTexture(ctx.TEXTURE_2D, null);
}

function draw_dots(ctx, stuff) {
    for (const pt of params.plot_points) {
        ctx.useProgram(stuff.shaderProgram);
        ctx.uniform2f(stuff.uVertexPosition, pt[0], pt[1]);
        ctx.uniform1f(stuff.uPointSize, 10.0);
        ctx.uniform3f(stuff.uColor, 0, 0, 1);
        ctx.drawArrays(ctx.POINTS, 0, 1);
    }
}

function paint() {
    const ctx = document.getElementById("canvas").getContext("webgl");
    if (params.high_count === 0) {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.main.framebuffer);
        ctx.viewport(0, 0, glStuff.main.fbWidth, glStuff.main.fbHeight);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        paintMandelbrot(ctx, glStuff.main, 0, 0);

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        blit_texture(ctx, glStuff.blit, glStuff.main.destTexture);
        draw_dots(ctx, glStuff.point);

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        params.high_count += 1;
        params.timer = setTimeout(paint, 300);
    } else {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.high.framebuffer);
        ctx.viewport(0, 0, glStuff.high.fbWidth, glStuff.high.fbHeight);

        if (params.high_count === 1) {
            ctx.clear(ctx.COLOR_BUFFER_BIT);
            paintMandelbrot(ctx, glStuff.high, 0, 0);
        } else {
            ctx.enable(ctx.BLEND);
            ctx.blendEquation(ctx.FUNC_ADD);
            ctx.blendFuncSeparate(ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA, ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA);
            ctx.blendColor(1.0, 1.0, 1.0, 1.0 / params.high_count);
            let nudgeX = (Math.random() - 0.5) * 0.5 / 100;
            let nudgeY = (Math.random() - 0.5) * 0.5 / 100;
            paintMandelbrot(ctx, glStuff.high, nudgeX, nudgeY);
            ctx.disable(ctx.BLEND);
        }

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        blit_texture(ctx, glStuff.blit, glStuff.high.destTexture);
        draw_dots(ctx, glStuff.point);

        params.high_count += 1;

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        if (params.high_count < 8) {
            params.timer = setTimeout(paint, 100);
        }
    }
}

function mousedown() {
    const x = event.clientX;
    const y = event.clientY;
    const originX = event.target.getBoundingClientRect().left;
    const originY = event.target.getBoundingClientRect().top;
    const hwidth = event.target.clientWidth / 2;
    const hheight = event.target.clientHeight / 2;
    const aspectX = event.target.clientWidth / Math.min(event.target.clientWidth, event.target.clientHeight);
    const aspectY = event.target.clientHeight / Math.min(event.target.clientWidth, event.target.clientHeight);
    const xy = [
        ((x - originX - hwidth) / hwidth) * aspectX,
        (-(y - originY - hheight) / hheight) * aspectY
    ];
    if (params.mandelbrot) {
        if (event.shiftKey) {
            params.ccenter = add(params.ccenter, mul(xy, params.cscale));
            params.cscale = mul(params.cscale, [0.25, 0.0]);
            repaint();
        } else {
            // target(xy[0], xy[1]);
            params.c = add(params.ccenter, mul(xy, params.cscale));
            params.mandelbrot = false;
            console.log("c = ", params.c)
            repaint();
        }
    } else {
        params.mandelbrot = true;
        repaint();
    }
}

function mousemove() {
}

function mousewheel() {
}

function touchstart() {
    event.preventDefault();
    for (const changedTouch of event.changedTouches) {
        if (touches.size === 0) {
            const offsetX = event.target.getBoundingClientRect().left;
            const offsetY = event.target.getBoundingClientRect().top;
            const x = (changedTouch.pageX - offsetX) / 200 - 1;
            const y = -(changedTouch.pageY - offsetY) / 200 + 2;

            const aVal = add(params.a, mul([x, y], params.ascale));
            const bVal = add(params.b, mul([x, y], params.bscale));
            const cVal = sub([1.0, 0.0], add(aVal, bVal));
            if (aVal > bVal && aVal > cVal) {
                params.touchSide = "a";
            } else if (bVal > cVal) {
                params.touchSide = "b";
            } else {
                params.touchSide = "c";
            }
            params.touchStartId = changedTouch.identifier;
        }

        const touch = {
            pageX: changedTouch.pageX,
            pageY: changedTouch.pageY,
            // startX: changedTouch.pageX,
            // startY: changedTouch.pageY,
            identifier: changedTouch.identifier,
        };

        touches.set(changedTouch.identifier, touch);
    }

    params.touchStartA = [params.a[0], params.a[1]];
    params.touchStartB = [params.b[0], params.b[1]];
    params.touchStartAScale = [params.ascale[0], params.ascale[1]];
    params.touchStartBScale = [params.bscale[0], params.bscale[1]];
    for (const touch of touches.values()) {
        touch.startX = touch.pageX;
        touch.startY = touch.pageY;
    }
}

function touchend() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];
    const ongoingTouch = touches.get(changedTouch.identifier);
    const deltaX = changedTouch.pageX - ongoingTouch.pageX;
    const deltaY = changedTouch.pageY - ongoingTouch.pageY;
    touches.delete(changedTouch.identifier);
}

function add(x, y) {
    return [
        x[0] + y[0],
        x[1] + y[1]
    ];
}

function add3(x, y, z) {
    return [
        x[0] + y[0] + z[0],
        x[1] + y[1] + z[1]
    ];
}

function add4(x, y, z, w) {
    return [
        x[0] + y[0] + z[0] + w[0],
        x[1] + y[1] + z[1] + w[1]
    ];
}

function sub(x, y) {
    return [
        x[0] - y[0],
        x[1] - y[1]
    ];
}

function mul(x, y) {
    return [
        x[0] * y[0] - x[1] * y[1],
        x[0] * y[1] + x[1] * y[0]
    ];
}

function div(x, y) {
    const denom = y[0] * y[0] + y[1] * y[1];
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function scale(r, c) {
    return [
        r * c[0],
        r * c[1]
    ];
}

function cnorm(c) {
    return Math.hypot(c[0], c[1]);
}

function touchmove() {
    event.preventDefault();
    for (let i = 0; i < event.changedTouches.length; i++) {
        const changedTouch = event.changedTouches[i];
        const ongoingTouch = touches.get(changedTouch.identifier);
        if (ongoingTouch) {
            ongoingTouch.pageX = changedTouch.pageX;
            ongoingTouch.pageY = changedTouch.pageY;
        }
    }

    if (touches.size === 1) {
        const offsetX = event.target.getBoundingClientRect().left;
        const offsetY = event.target.getBoundingClientRect().top;

        const touch0 = touches.get(params.touchStartId);
        if (!touch0) {
            return;
        }
        let x = (touch0.pageX - touch0.startX) / 200;
        let y = -(touch0.pageY - touch0.startY) / 200;

        let ascaled = mul(params.touchStartAScale, [x,y]);
        let bscaled = mul(params.touchStartBScale, [x,y]);
        if (params.drag === "zoom") {
            params.a = sub(params.touchStartA, ascaled);
            params.b = sub(params.touchStartB, bscaled);
        } else if (params.drag === "distort") {
            params.a[1] = params.touchStartA[1] - ascaled[1];
            params.b[1] = params.touchStartB[1] - bscaled[1];
        }

        // params.ascale[1] = params.touchStartAScale[1] - ascaled[1];
        // params.bscale[1] = params.touchStartBScale[1] - bscaled[1];

        repaint();
    }
    
    if (touches.size === 2) {
        const touch0 = touches.get(params.touchStartId);
        const touch1 = Array.from(touches.values()).find(t => t.identifier !== params.touchStartId);
        if (!touch0 || !touch1) {
            return;
        }

        let x0 = (touch0.pageX - touch0.startX) / 200;
        let y0 = -(touch0.pageY - touch0.startY) / 200;

        let x1 = (touch1.pageX - touch1.startX) / 200;
        let y1 = -(touch1.pageY - touch1.startY) / 200;

        let startd = [
            touch1.startX - touch0.startX,
            -(touch1.startY - touch0.startY)
        ];
        let endd = [
            touch1.pageX - touch0.pageX,
            -(touch1.pageY - touch0.pageY)
        ];
        let rotate = div(startd, endd);

        let ascaled = mul(params.touchStartAScale, [x0,y0]);
        let bscaled = mul(params.touchStartBScale, [x0,y0]);
        if (params.drag === "zoom") {
            params.a = sub(params.touchStartA, ascaled);
            params.b = sub(params.touchStartB, bscaled);
            params.ascale = mul(params.touchStartAScale, rotate);
            params.bscale = mul(params.touchStartBScale, rotate);
        }
        repaint();
    }
}

function repaint() {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    paint();
}

function scale_rotate(scaleX, scaleY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.mandelbrot) {
        if (params.drag === "ca") {
            let c0 = -params.ascale[0] - params.bscale[0];
            let c1 = -params.ascale[1] - params.bscale[1];
            let cincrx = c0 * scaleX - c1 * scaleY - c0;
            let cincry = c0 * scaleY + c1 * scaleX - c1;
            params.ascale[0] -= cincrx;
            params.ascale[1] -= cincry;
        }
        if (params.drag === "bc") {
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
        if (params.drag === "ab") {
            let aincrx = params.ascale[0] * scaleX - params.ascale[1] * scaleY - params.ascale[0];
            let aincry = params.ascale[0] * scaleY + params.ascale[1] * scaleX - params.ascale[1];
            params.ascale[0] += aincrx;
            params.ascale[1] += aincry;
            params.bscale[0] -= aincrx;
            params.bscale[1] -= aincry;
        }
        if (params.drag === "all") {
            params.ascale = [
                params.ascale[0] * scaleX - params.ascale[1] * scaleY,
                params.ascale[0] * scaleY + params.ascale[1] * scaleX
            ];
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
    } else {
        params.z0Scale /= scale;
    }
}

function move(deltaX, deltaY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.drag === "ca") {
        const cscale = [
            (scale[0] + params.bscale[0]),
            (params.ascale[1] + params.bscale[1])
        ];
        params.a[0] += deltaX * cscale[0] - deltaY * cscale[1];
        params.a[1] += deltaY * cscale[0] + deltaX * cscale[1];
    }
    if (params.drag === "bc") {
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
    if (params.drag === "ab") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] -= deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.b[1] -= deltaY * params.ascale[0] + deltaX * params.ascale[1];
    }
    if (params.drag === "all") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
}

function update_buttons() {
    document.getElementById("button_distort").classList.remove("active");
    document.getElementById("button_zoom").classList.remove("active");
    if (params.drag === "distort") {
        document.getElementById("button_distort").classList.add("active");
    } else if (params.drag === "zoom") {
        document.getElementById("button_zoom").classList.add("active");
    }
}


function csqrt(z) {
    const r = Math.sqrt(cnorm(z));
    const theta = Math.atan2(z[1], z[0]);
    return [
        r * Math.cos(theta / 2.0),
        r * Math.sin(theta / 2.0)
    ];
}

function solve_quadratic(a, b, c) {
    const discriminant = csqrt(sub(mul(b, b), scale(4.0, mul(a, c))));
    const root1 = div(sub(discriminant, b), scale(2.0, a));
    return root1;
}

class Derivatives {
    constructor(value, dz, dc) {
        this.value = value;
        this.dz = dz;
        this.dc = dc;
    }

    static fromConstant(value) {
        const z = [0.0, 0.0];
        return new Derivatives(value, z, z);
    }

    static fromRealConstant(value) {
        return Derivatives.fromConstant([value, 0.0]);
    }

    static fromZ(z) {
        const one = [1.0, 0.0];
        const zero = [0.0, 0.0];
        return new Derivatives(z, one, zero);
    }

    static fromC(p) {
        const one = [1.0, 0.0];
        const zero = [0.0, 0.0];
        return new Derivatives(p, zero, one);
    }

    add(other) {
        return new Derivatives(
            add(this.value, other.value),
            add(this.dz, other.dz),
            add(this.dc, other.dc)
        );
    }

    sub(other) {
        return new Derivatives(
            sub(this.value, other.value),
            sub(this.dz, other.dz),
            sub(this.dc, other.dc)
        );
    }

    scale(r) {
        return new Derivatives(
            scale(r, this.value),
            scale(r, this.dz),
            scale(r, this.dc)
        );
    }

    mul(other) {
        return new Derivatives(
            mul(this.value, other.value),
            add(
                mul(this.dz, other.value),
                mul(this.value, other.dz)
            ),
            add(
                mul(this.dc, other.value),
                mul(this.value, other.dc)
            )
        );
    }

    recip() {
        const f = div([1.0, 0.0], this.value);
        const f1 = scale(-1, mul(f, f));
        return new Derivatives(
            f,
            mul(f1, this.dz),
            mul(f1, this.dc)
        );
    }

    square() {
        return this.mul(this);
    }

    div(other) {
        return this.mul(other.recip());
    }
}

function target(x, y) {
    const n = 100;
    const n2 = n + 3;
    const start_summing = n2 - 30;
    const maxiter = n + 90;
    const maxper = 10;
    const bailout = 100.0;
    let pixel = add(mul([x,y], params.cscale), params.ccenter);
    let c = Derivatives.fromC(pixel);
    let z0 = Derivatives.fromZ([0.0, 0.0]).add(c);
    let z = z0;
    let escaped = false;
    let n_dc = null;
    let n_dz = null;
    let dcs = [];
    let dzs = [];
    let iters = [];
    let sum_dc = [0.0, 0.0];
    let sum_denom = 0;
    for (let i = 0 ; i < maxiter; i++) {
        if (i === n) {
            n_dz = z.dz;
            n_dc = z.dc;
        }
        if (i % 3 === n % 3) {
            dcs.push(z.dc);
            dzs.push(z.dz);
            iters.push(i);
        }
        if (i % 3 === 0 && i >= start_summing) {
            sum_dc = add(sum_dc, z.dc);
            sum_denom += 1;
        }
        z = z.square().add(c);
        if (cnorm(z.value) > bailout) {
            console.log("Escaped after", i, "iterations");
            escaped = true;
            break;
        }
    }
    sum_dc = scale(1.0 / sum_denom, sum_dc);

    let ratio = null;
    if (!escaped) {
        console.log("Did not escape");
        ratio = div(sub(n_dc, sum_dc), n_dz);
        console.log("Sum dc", sum_dc);
        // let sum = [0.0, 0.0];
        // for (let i = 0; i < dcs.length; i++) {
        //     const dc = dcs[i];
        //     const dz = dzs[i];
        //     const ratio2 = div(sub(dc, sum_dc), dz);
        //     console.log("Ratio check:", ratio2, iters[i], sub(dc, z.dc), sum);
        //     sum = add(sum, sub(dc, sum_dc));
        // }
    } else {
        ratio = div(z.dc, z.dz);
    }

    params.c = c.value;
    params.z0Scale = mul(ratio, params.cscale);
    params.z0 = sub(z0.value, mul([x,y], params.z0Scale));
    params.mandelbrot = false;
    console.log("Ratio:", ratio);

    // params.plot_points = [[x,y]];

    repaint();
}

function start() {
    glStuff = setup();
    update_buttons();
    paint();
}

window.onload = start;
    </script>
    <style>
button {
    padding: 10px;
}
button.active {
    background: #ffaaaa;
}
    </style>
</head>
<body>
    <button id="button_zoom" onclick="params.drag='zoom'; update_buttons()">Zoom</button>
    <button id="button_distort" onclick="params.drag='distort'; update_buttons()">Distort</button>
    <br>
    <canvas id="canvas" width="1600" height="800" onmousedown="mousedown()" onmousemove="mousemove()" onwheel="mousewheel()" ontouchstart="touchstart()" ontouchmove="touchmove()" ontouchend="touchend()"></canvas>
</body>
</html>