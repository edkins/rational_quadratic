<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

const showDots = false;
const showHigh = false;

const MAXIMUM = 20;
const PMAXIMUM = 5;

function make_angles() {
    let result = [];
    for (let j = 1; j <= PMAXIMUM; j++) {
        let denom = (1<<j) - 1;
        for (let i = 0; i <= denom; i++) {
            let found = false;
            for (let k = 0; k < result.length; k++) {
                if (result[k][2] * denom === i * result[k][3]) {
                    found = true;
                }
            }
            if (!found) {
                result.push([i / denom, j, i, denom]);
            }
        }
    }
    result.sort((a,b) => a[0]-b[0]);
    let result_a = [];
    let result_j = [];
    for (let i = 0; i < result.length; i++) {
        result_a.push(result[i][0]);
        result_j.push(result[i][1]);
    }
    return [result_a, result_j];
}

const [angles, angles_j] = make_angles();

// const angles = [
//     0,
//     1/31,
//     2/31,
//     1/15,
//     3/31,
//     4/31,
//     2/15,
//     1/7,
//     5/31,
//     6/31,
//     3/15,
//     7/31,
//     8/31,
//     4/15,
//     2/7,
//     9/31,
//     10/31,

//     1/3,
//     11/31,
//     12/31,
//     6/15,
//     13/31,
//     3/7,
//     14/31,
//     7/15,
//     15/31,


//     16/31,
//     8/15,
//     17/31,
//     4/7,
//     18/31,
//     9/15,
//     19/31,
//     20/31,
//     2/3,

//     21/31,
//     22/31,
//     5/7,
//     11/15,
//     23/31,
//     24/31,
//     12/15,
//     25/31,
//     26/31,
//     6/7,
//     13/15,
//     27/31,
//     28/31,
//     14/15,
//     29/31,
//     30/31,
// ];

const uPowersArrays = {
    1: [0,1],
    2: [0,0,1],
    3: [0,-1,1,1],
    4: [0,0,-1,1,1],
    5: [0,-1,0,1,1,1],
}

let params = {
    ccenter: [-0.65, 0.0],
    cscale: [1.5, 0.0],

    c: [-0.0, 0.0],
    z0: [0.0, 0.0],
    z0Scale: [2.0, 0.0],
    mandelbrot: true,

    color: true,
    drag: "zoom",
    drag_start: [0.0, 0.0],
    timer: null,
    last_moved: 0,
    high_count: 0,
    touchStartA: null,
    touchStartB: null,
    touchStartAScale: null,
    touchStartBScale: null,
    touchSide: null,
    touchStartId: null,
    plot_points: [],
    plot_colors: [],
    unscaled_points: [],

    j: 3,
    contour: [-5.0, 1.0],

    frac: {num:0,denom:7}
    // frac: binfrac("","000111")
};
let glStuff = null;
let touches = new Map();

function binfrac(fixed, recurring) {
    let num = 0;
    if (fixed !== "") {
        num = parseInt(fixed, 2);
    }
    let denom = Math.pow(2, fixed.length);

    if (recurring !== undefined && recurring !== "") {
        let pot = Math.pow(2, recurring.length);
        num = num * (pot - 1) + parseInt(recurring, 2);
        denom *= pot - 1;
    }

    console.log("binfrac",num,denom);
    return {num, denom};
}

function fragmentShaderSource(max_iter, max_period) {
    return `
        precision highp float;
        varying vec2 c;
        varying vec2 z0;
        uniform bool uMandelbrot;
        uniform float uBailout;
        uniform float uFracNum;
        uniform float uFracDenom;
        uniform vec2 ucscale;
        uniform vec2 uContour;
        uniform float uAngles[${angles.length}];
        uniform vec3 uPalette[${angles.length}];
        uniform int j;
        uniform sampler2D fracTexture;
        const vec2 one = vec2(1.0, 0.0);
        const vec2 zero = vec2(0.0, 0.0);

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 csquare(vec2 z) {
            return vec2(
                z.x * z.x - z.y * z.y,
                2.0 * z.x * z.y
            );
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        vec2 recip(vec2 z) {
            float denom = z.x * z.x + z.y * z.y;
            return vec2(
                z.x / denom,
                -z.y / denom);
        }

        vec2 csqrt(vec2 z) {
            float r = length(z);
            float theta = atan(z.y, z.x);
            return vec2(
                sqrt(r) * cos(theta / 2.0),
                sqrt(r) * sin(theta / 2.0)
            );
        }

        vec2 other_csqrt(vec2 z) {
            float r = sqrt(length(z));
            float theta = atan(-z.y, -z.x);
            return vec2(
                -r * sin(theta / 2.0),
                r * cos(theta / 2.0)
            );
        }

        float angle(vec2 z) {
            return mod(atan(z.y,z.x) / 6.28318530718, 1.0);
        }

        float atan2(vec2 z) {
            return atan(z.y, z.x);
        }

        vec2 cexp(vec2 z) {
            return exp(z.x) * vec2(cos(z.y), sin(z.y));
        }

        vec2 clog(vec2 z) {
            return vec2(log(length(z)), atan(z.y, z.x));
        }

        vec2 cpow(vec2 z, int p) {
            float r = pow(length(z), float(p));
            float theta = atan(z.y, z.x) * float(p);
            return vec2(
                r * cos(theta),
                r * sin(theta)
            );
        }

        float nearest(float course, float fine) {
            return fine + floor(course - fine + 0.5);
        }

        float frac(float x) {
            return x - floor(x);
        }

        int nearest_yikes(float course, float fine) {
            if (frac(course - fine + 0.5) < 0.01) {
                return -1;
            }
            if (frac(course - fine + 0.5) > 0.99) {
                return 1;
            }
            return 0;
        }

        float find_int_between(float ang_min, float ang_max) {
            float middle = (ang_min + ang_max) * 0.5;
            return floor(middle + 0.5);
        }

        struct D {
            vec2 value;
            vec2 dc;
        };

        D dsquare(D z) {
            return D(
                mul(z.value, z.value),
                2.0 * mul(z.value, z.dc));
        }

        D dmul(D x, D y) {
            return D(
                mul(x.value, y.value),
                mul(x.value, y.dc) + mul(y.value, x.dc)
            );
        }

        D dadd(D a, D b) {
            return D(
                a.value + b.value,
                a.dc + b.dc);
        }

        D dadd_const(D a, vec2 c) {
            return D(
                a.value + c,
                a.dc
            );
        }

        D dsqrt(D z) {
            vec2 s = csqrt(z.value);
            return D(
                s,
                0.5 * div(z.dc, s)
            );
        }

        D drsqrt(D z) {
            vec2 s = recip(other_csqrt(z.value));
            return D(
                s,
                -0.5 * div(s, z.dc)
            );
        }

        D dbar(D z) {
            return D(
                vec2(-z.value.x, z.value.y),
                z.dc
            );
        }

        D dpow(D z, int n) {
            vec2 p = cpow(z.value, n);
            return D(
                p,
                float(n) * div(mul(p, z.dc), z.value)
            );
        }

        vec4 mandelbrot(vec2 actual_z0) {
            D z = D(actual_z0, one);
            D cc = D(c, one);
            int escaped = ${max_iter};
            float ang_min = -1.;
            float ang_max = 1.;
            const int maximum = ${MAXIMUM};
            float denom = 1.0;
            bool yikes = false;
            float w = 0.0;
            bool highlight = false;
            for (int iteration = 1; iteration < ${max_iter}; iteration++) {
                if (iteration <= maximum) {
                    float candidate = angle(z.value);
                    float n = find_int_between(ang_min - candidate, ang_max - candidate);
                    // if (n < ang_min - candidate || n > ang_max - candidate) {
                    //     return vec4(1.0, 0.0, 0.0, 1.0);
                    // }
                    float ang_middle = candidate + n;
                    yikes = yikes || ang_middle - 0.501 < ang_min || ang_middle + 0.501 > ang_max;
                    ang_min = clamp(ang_middle - 0.5, ang_min, ang_max);
                    ang_max = clamp(ang_middle + 0.5, ang_min, ang_max);
                    ang_min *= 2.0;
                    ang_max *= 2.0;
                    denom *= 0.5;
                    w = 0.0003 * length(ucscale) * denom / length(z.value) * length(z.dc);
                }
                if (length(z.value) > uBailout) {
                    escaped = iteration;
                    break;
                }
                z = dadd(dsquare(z), cc);
            }
            if (!uMandelbrot) {
                w = 0.0003;
            }
            float ang = (ang_min + ang_max) * 0.5;
            ang *= denom;
            ang = mod(ang, 1.0);
            ang_min = mod(ang_min * denom, 1.0);
            ang_max = mod(ang_max * denom, 1.0);

            float fiter = log(float(escaped)) / 15.0;
            if (escaped == ${max_iter}) {
                return vec4(0.0, 0.0, 0.0, 1.0);
            }
            vec3 color = vec3(fiter, fiter, fiter);
            if (highlight) {
                color.r += 0.2;
            }
            vec4 nearest_tex = texture2D(fracTexture, vec2(0,ang));
            float nearest_frac = nearest_tex.r / nearest_tex.g;
            if (yikes) {
                return vec4(0.5, 0.5, 1.0, 1.0);
            }
            if (abs(nearest_frac - ang) <= w) {
                return texture2D(fracTexture, vec2(1,ang));
            }
            return vec4(color, 1.0);
        }

        void main(void) {
            if (uMandelbrot) {
                gl_FragColor = mandelbrot(c);
            } else {
                gl_FragColor = mandelbrot(z0);
            }
        }
    `;
}
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.9, 0.9, 1.0);

    // Mandelbrot vertex shader program
    const vsSource = `
        precision highp float;
        attribute vec2 aVertexPosition;
        uniform vec2 uz0;
        uniform vec2 uz0Scale;
        uniform vec2 uc;
        uniform vec2 ucscale;
        uniform vec2 uNudge;
        varying vec2 c;
        varying vec2 z0;
        uniform vec2 aspect;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vec2 vp = aVertexPosition * aspect + uNudge;
            c = uc + mul(vp, ucscale);
            z0 = uz0 + mul(vp, uz0Scale);
        }
    `;

    // Mandelbrot/Julia fragment shader program
    const fsSource = fragmentShaderSource(200, 32);
    const fsSourceHigh = fragmentShaderSource(2000, 100);

    // Initialize shaders
    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);

    // Initialize shaders (high iteration count)
    const fragmentShaderHigh = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderHigh, fsSourceHigh);
    ctx.compileShader(fragmentShaderHigh);
    if (!ctx.getShaderParameter(fragmentShaderHigh, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the high iteration shader: " +
            ctx.getShaderInfoLog(fragmentShaderHigh));
        return null;
    }
    const shaderProgramHigh = ctx.createProgram();
    ctx.attachShader(shaderProgramHigh, vertexShader);
    ctx.attachShader(shaderProgramHigh, fragmentShaderHigh);
    ctx.linkProgram(shaderProgramHigh);

    // Shaders for texture blitting
    const vsSourceBlit = `
        attribute vec2 aVertexPosition;
        varying vec2 vTexCoord;
        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vTexCoord = (aVertexPosition + vec2(1.0, 1.0)) * 0.5;
        }
    `;
    const fsSourceBlit = `
        precision highp float;
        varying vec2 vTexCoord;
        uniform sampler2D uTexture;
        void main(void) {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;
    const vertexShaderBlit = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderBlit, vsSourceBlit);
    ctx.compileShader(vertexShaderBlit);
    const fragmentShaderBlit = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderBlit, fsSourceBlit);
    ctx.compileShader(fragmentShaderBlit);
    if (!ctx.getShaderParameter(vertexShaderBlit, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderBlit, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the blit shaders: " +
            ctx.getShaderInfoLog(vertexShaderBlit) + " " +
            ctx.getShaderInfoLog(fragmentShaderBlit));
        return null;
    }
    const shaderProgramBlit = ctx.createProgram();
    ctx.attachShader(shaderProgramBlit, vertexShaderBlit);
    ctx.attachShader(shaderProgramBlit, fragmentShaderBlit);
    ctx.linkProgram(shaderProgramBlit);

    // Shaders for point markers
    const vsSourcePoint = `
        precision highp float;
        uniform vec2 uVertexPosition;
        uniform float uPointSize;
        uniform vec2 aspect;
        void main(void) {
            gl_Position = vec4(uVertexPosition / aspect, 0.0, 1.0);
            gl_PointSize = uPointSize;
        }
    `;
    const fsSourcePoint = `
        precision highp float;
        uniform vec3 uColor;
        void main(void) {
            gl_FragColor = vec4(uColor, 1.0);
        }
    `;
    const vertexShaderPoint = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderPoint, vsSourcePoint);
    ctx.compileShader(vertexShaderPoint);
    const fragmentShaderPoint = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderPoint, fsSourcePoint);
    ctx.compileShader(fragmentShaderPoint);
    if (!ctx.getShaderParameter(vertexShaderPoint, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderPoint, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the point shaders: " +
            ctx.getShaderInfoLog(vertexShaderPoint) + " " +
            ctx.getShaderInfoLog(fragmentShaderPoint));
        return null;
    }
    const shaderProgramPoint = ctx.createProgram();
    ctx.attachShader(shaderProgramPoint, vertexShaderPoint);
    ctx.attachShader(shaderProgramPoint, fragmentShaderPoint);
    ctx.linkProgram(shaderProgramPoint);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    // Create texture to hold low-iteration Mandelbrot image
    const fbWidth = ctx.canvas.width;
    const fbHeight = ctx.canvas.height;
    const destTexture = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTexture);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidth, fbHeight, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render low-iteration Mandelbrot image into
    const framebuffer = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffer);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTexture, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    // Create texture to hold high-iteration Mandelbrot image
    const fbWidthHigh = fbWidth;
    const fbHeightHigh = fbHeight;
    const destTextureHigh = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTextureHigh);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidthHigh, fbHeightHigh, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render high-iteration Mandelbrot image into
    const framebufferHigh = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebufferHigh);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTextureHigh, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    // Create texture to hold fractions
    const fracTextureH = 8192;
    const fraction_texture_data = new Uint8Array(fracTextureH*8);
    for (let i = 0; i < fracTextureH; i++) {
        let x = (i + 0.5) / fracTextureH;
        let nearest_k = 0;
        for (let k = 0; k < angles.length; k++) {
            if (Math.abs(x - angles[k]) < Math.abs(x-angles[nearest_k])) {
                nearest_k = k;
            }
        }
        const denominator = (1 << angles_j[nearest_k]) - 1;
        const numerator = Math.round(angles[nearest_k] * denominator);
        if (denominator > 255) {
            throw "This won't work";
        }
        
        console.log(nearest_k, numerator, denominator);
        fraction_texture_data[8*i] = numerator;
        fraction_texture_data[8*i+1] = denominator;
        const p = palette[angles_j[nearest_k]-1];
        fraction_texture_data[8*i+4] = p[0] * 255;
        fraction_texture_data[8*i+5] = p[1] * 255;
        fraction_texture_data[8*i+6] = p[2] * 255;
        fraction_texture_data[8*i+7] = 255;
    }
    const fracTexture = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, fracTexture);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, 2, fracTextureH, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, fraction_texture_data);  
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.NEAREST);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.NEAREST);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    return {
        main: {
            shaderProgram,
            aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgram, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgram, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgram, "uz0Scale"),
            uc: ctx.getUniformLocation(shaderProgram, "uc"),
            ucscale: ctx.getUniformLocation(shaderProgram, "ucscale"),
            uBailout: ctx.getUniformLocation(shaderProgram, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgram, "uBailin"),
            bailin: 0.002,
            bailout: 100,
            uNudge: ctx.getUniformLocation(shaderProgram, "uNudge"),
            vertexBuffer,
            destTexture,
            framebuffer,
            fbWidth,
            fbHeight,
            uBrightness: ctx.getUniformLocation(shaderProgram, "uBrightness"),
            brightness: 0.02,
            uAspect: ctx.getUniformLocation(shaderProgram, "aspect"),
            uFracNum: ctx.getUniformLocation(shaderProgram, "uFracNum"),
            uFracDenom: ctx.getUniformLocation(shaderProgram, "uFracDenom"),
            uPowers: ctx.getUniformLocation(shaderProgram, "uPowers"),
            uPalette: ctx.getUniformLocation(shaderProgram, "uPalette"),
            uAngles: ctx.getUniformLocation(shaderProgram, "uAngles"),
            uj: ctx.getUniformLocation(shaderProgram, "j"),
            uContour: ctx.getUniformLocation(shaderProgram, "uContour"),
            uFracTexture: ctx.getUniformLocation(shaderProgram, "fracTexture"),
            fracTexture,
        },
        high: {
            shaderProgram: shaderProgramHigh,
            aVertexPosition: ctx.getAttribLocation(shaderProgramHigh, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgramHigh, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgramHigh, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgramHigh, "uz0Scale"),
            uc: ctx.getUniformLocation(shaderProgramHigh, "uc"),
            uascale: ctx.getUniformLocation(shaderProgramHigh, "uascale"),
            ucscale: ctx.getUniformLocation(shaderProgramHigh, "ucscale"),
            uBailout: ctx.getUniformLocation(shaderProgramHigh, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgramHigh, "uBailin"),
            bailin: 0.001,
            bailout: 100,
            uNudge: ctx.getUniformLocation(shaderProgramHigh, "uNudge"),
            vertexBuffer,
            destTexture: destTextureHigh,
            framebuffer: framebufferHigh,
            fbWidth: fbWidthHigh,
            fbHeight: fbHeightHigh,
            uBrightness: ctx.getUniformLocation(shaderProgramHigh, "uBrightness"),
            brightness: 0.02,
            uAspect: ctx.getUniformLocation(shaderProgramHigh, "aspect"),
            uFracNum: ctx.getUniformLocation(shaderProgramHigh, "uFracNum"),
            uFracDenom: ctx.getUniformLocation(shaderProgramHigh, "uFracDenom"),
            uPowers: ctx.getUniformLocation(shaderProgramHigh, "uPowers"),
            uPalette: ctx.getUniformLocation(shaderProgramHigh, "uPalette"),
            uAngles: ctx.getUniformLocation(shaderProgramHigh, "uAngles"),
            uj: ctx.getUniformLocation(shaderProgramHigh, "j"),
            uContour: ctx.getUniformLocation(shaderProgramHigh, "uContour"),
            uFracTexture: ctx.getUniformLocation(shaderProgramHigh, "fracTexture"),
            fracTexture,
        },
        blit: {
            shaderProgram: shaderProgramBlit,
            aVertexPosition: ctx.getAttribLocation(shaderProgramBlit, "aVertexPosition"),
            uTexture: ctx.getUniformLocation(shaderProgramBlit, "uTexture"),
            vertexBuffer,
        },
        point: {
            shaderProgram: shaderProgramPoint,
            uVertexPosition: ctx.getUniformLocation(shaderProgramPoint, "uVertexPosition"),
            uPointSize: ctx.getUniformLocation(shaderProgramPoint, "uPointSize"),
            uColor: ctx.getUniformLocation(shaderProgramPoint, "uColor"),
            uAspect: ctx.getUniformLocation(shaderProgramPoint, "aspect"),
        }
    };
}

function paintMandelbrot(ctx, stuff, nudgeX, nudgeY) {
    // Draw the Julia or Mandelbrot set
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform1f(stuff.uBailout, stuff.bailout);
    ctx.uniform2f(stuff.uNudge, nudgeX, nudgeY);
    ctx.uniform2f(stuff.uAspect, ctx.canvas.width / Math.min(ctx.canvas.width, ctx.canvas.height), ctx.canvas.height / Math.min(ctx.canvas.width, ctx.canvas.height));
    ctx.uniform1f(stuff.uFracNum, params.frac.num);
    ctx.uniform1f(stuff.uFracDenom, params.frac.denom);

    // ctx.uniform1iv(stuff.uPowers, uPowersArrays[B]);
    const paletteConcat = [];
    for (let i = 0; i < angles_j.length; i++) {
        paletteConcat.push(...palette[angles_j[i]-1]);
    }
    ctx.uniform3fv(stuff.uPalette, paletteConcat);
    ctx.uniform1fv(stuff.uAngles, angles);
    ctx.uniform1i(stuff.uj, params.j);
    ctx.uniform2f(stuff.uContour, params.contour[0], params.contour[1]);
    ctx.activeTexture(ctx.TEXTURE0);
    ctx.bindTexture(ctx.TEXTURE_2D, stuff.fracTexture);
    ctx.uniform1i(stuff.uFracTexture, 0);

    if (params.mandelbrot) {
        ctx.uniform1i(stuff.uMandelbrot, true);
        ctx.uniform2f(stuff.uz0Scale, 0.0, 0.0);
        ctx.uniform2f(stuff.uc, params.ccenter[0], params.ccenter[1]);
        ctx.uniform2f(stuff.ucscale, params.cscale[0], params.cscale[1]);
    } else {
        ctx.uniform1i(stuff.uMandelbrot, false);
        ctx.uniform2f(stuff.uz0Scale, params.z0Scale[0], params.z0Scale[1]);
        ctx.uniform2f(stuff.uc, params.c[0], params.c[1]);
        ctx.uniform2f(stuff.ucscale, 0.0, 0.0);
        ctx.uniform2f(stuff.uz0, params.z0[0], params.z0[1]);
    }
    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
    ctx.bindTexture(ctx.TEXTURE_2D, null);
}

function blit_texture(ctx, stuff, texture) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.activeTexture(ctx.TEXTURE0);
    ctx.bindTexture(ctx.TEXTURE_2D, texture);
    ctx.uniform1i(stuff.uTexture, 0);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);

    ctx.bindTexture(ctx.TEXTURE_2D, null);
}

function draw_dots(ctx, stuff) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform1f(stuff.uPointSize, 4.0);
    ctx.uniform2f(stuff.uAspect, ctx.canvas.width / Math.min(ctx.canvas.width, ctx.canvas.height), ctx.canvas.height / Math.min(ctx.canvas.width, ctx.canvas.height));

    for (let i = params.plot_points.length-1; i >= 0; i--) {
        const pt = params.plot_points[i];
        const col = params.plot_colors[i];
        ctx.uniform2f(stuff.uVertexPosition, pt[0], pt[1]);
        ctx.uniform3f(stuff.uColor, col[0], col[1], col[2]);
        ctx.drawArrays(ctx.POINTS, 0, 1);
    }
}

function paint() {
    const ctx = document.getElementById("canvas").getContext("webgl");
    if (params.high_count === 0) {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.main.framebuffer);
        ctx.viewport(0, 0, glStuff.main.fbWidth, glStuff.main.fbHeight);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        paintMandelbrot(ctx, glStuff.main, 0, 0);

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        blit_texture(ctx, glStuff.blit, glStuff.main.destTexture);
        draw_dots(ctx, glStuff.point);

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        if (showHigh) {
            params.high_count += 1;
            params.timer = setTimeout(paint, 300);
        }
    } else {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.high.framebuffer);
        ctx.viewport(0, 0, glStuff.high.fbWidth, glStuff.high.fbHeight);

        if (params.high_count === 1) {
            ctx.clear(ctx.COLOR_BUFFER_BIT);
            paintMandelbrot(ctx, glStuff.high, 0, 0);
        } else {
            ctx.enable(ctx.BLEND);
            ctx.blendEquation(ctx.FUNC_ADD);
            ctx.blendFuncSeparate(ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA, ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA);
            ctx.blendColor(1.0, 1.0, 1.0, 1.0 / params.high_count);
            let nudgeX = (Math.random() - 0.5) * 0.5 / 100;
            let nudgeY = (Math.random() - 0.5) * 0.5 / 100;
            paintMandelbrot(ctx, glStuff.high, nudgeX, nudgeY);
            ctx.disable(ctx.BLEND);
        }

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        blit_texture(ctx, glStuff.blit, glStuff.high.destTexture);
        draw_dots(ctx, glStuff.point);

        params.high_count += 1;

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        if (params.high_count < 8) {
            params.timer = setTimeout(paint, 100);
        }
    }
}

function mousedown() {
    const x = event.clientX;
    const y = event.clientY;
    const originX = event.target.getBoundingClientRect().left;
    const originY = event.target.getBoundingClientRect().top;
    const hwidth = event.target.clientWidth / 2;
    const hheight = event.target.clientHeight / 2;
    const aspectX = event.target.clientWidth / Math.min(event.target.clientWidth, event.target.clientHeight);
    const aspectY = event.target.clientHeight / Math.min(event.target.clientWidth, event.target.clientHeight);
    const xy = [
        ((x - originX - hwidth) / hwidth) * aspectX,
        (-(y - originY - hheight) / hheight) * aspectY
    ];
    if (event.ctrlKey) {
        if (params.mandelbrot) {
            params.mandelbrot = false;
            params.c = add(params.ccenter, mul(xy, params.cscale));
            repaint();
        } else {
            params.mandelbrot = true;
            repaint();
        }
    } else if (event.shiftKey) {
        params.j = Math.max(1, params.j-1);
        repaint();
    } else {
        params.j = params.j + 1;
        repaint();
    }
}

function mousemove() {
    if (event.shiftKey) {
        const x = event.clientX;
        const y = event.clientY;
        const originX = event.target.getBoundingClientRect().left;
        const originY = event.target.getBoundingClientRect().top;
        const hwidth = event.target.clientWidth / 2;
        const hheight = event.target.clientHeight / 2;
        const aspectX = event.target.clientWidth / Math.min(event.target.clientWidth, event.target.clientHeight);
        const aspectY = event.target.clientHeight / Math.min(event.target.clientWidth, event.target.clientHeight);

        const xy = [
            ((x - originX - hwidth) / hwidth) * aspectX,
            (-(y - originY - hheight) / hheight) * aspectY
        ];
        const c = add(params.ccenter, mul(xy, params.cscale));
        let z = [0,0];
        for (let i = 0; i < params.j; i++) {
            z = mul(c, add(mul(z,z), [1,0]));
        }
        // let param = (y - originY) / hheight - 1;
        params.contour = z;
        repaint();
    }
}

function mousewheel() {
    const x = event.clientX;
    const y = event.clientY;
    const originX = event.target.getBoundingClientRect().left;
    const originY = event.target.getBoundingClientRect().top;
    const hwidth = event.target.clientWidth / 2;
    const hheight = event.target.clientHeight / 2;
    const aspectX = event.target.clientWidth / Math.min(event.target.clientWidth, event.target.clientHeight);
    const aspectY = event.target.clientHeight / Math.min(event.target.clientWidth, event.target.clientHeight);
    let sc = Math.pow(1.001, event.deltaY);
    const xy = [
        ((x - originX - hwidth) / hwidth) * aspectX,
        (-(y - originY - hheight) / hheight) * aspectY
    ];
    if (params.mandelbrot) {
        params.ccenter = add(params.ccenter, scale((1 - sc) * 1.2, mul(xy, params.cscale)));
        params.cscale[0] *= sc;
        params.cscale[1] *= sc;
    } else {
        params.z0 = add(params.z0, scale((1 - sc) * 1.2, mul(xy, params.z0Scale)));
        params.z0Scale = scale(sc, params.z0Scale);

    }
    repaint();
}

function touchstart() {
    event.preventDefault();
    for (const changedTouch of event.changedTouches) {
        if (touches.size === 0) {
            const offsetX = event.target.getBoundingClientRect().left;
            const offsetY = event.target.getBoundingClientRect().top;
            const x = (changedTouch.pageX - offsetX) / 200 - 1;
            const y = -(changedTouch.pageY - offsetY) / 200 + 2;

            const aVal = add(params.a, mul([x, y], params.ascale));
            const bVal = add(params.b, mul([x, y], params.bscale));
            const cVal = sub([1.0, 0.0], add(aVal, bVal));
            if (aVal > bVal && aVal > cVal) {
                params.touchSide = "a";
            } else if (bVal > cVal) {
                params.touchSide = "b";
            } else {
                params.touchSide = "c";
            }
            params.touchStartId = changedTouch.identifier;
        }

        const touch = {
            pageX: changedTouch.pageX,
            pageY: changedTouch.pageY,
            // startX: changedTouch.pageX,
            // startY: changedTouch.pageY,
            identifier: changedTouch.identifier,
        };

        touches.set(changedTouch.identifier, touch);
    }

    params.touchStartA = [params.a[0], params.a[1]];
    params.touchStartB = [params.b[0], params.b[1]];
    params.touchStartAScale = [params.ascale[0], params.ascale[1]];
    params.touchStartBScale = [params.bscale[0], params.bscale[1]];
    for (const touch of touches.values()) {
        touch.startX = touch.pageX;
        touch.startY = touch.pageY;
    }
}

function touchend() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];
    const ongoingTouch = touches.get(changedTouch.identifier);
    const deltaX = changedTouch.pageX - ongoingTouch.pageX;
    const deltaY = changedTouch.pageY - ongoingTouch.pageY;
    touches.delete(changedTouch.identifier);
}

function add(x, y) {
    return [
        x[0] + y[0],
        x[1] + y[1]
    ];
}

function add3(x, y, z) {
    return [
        x[0] + y[0] + z[0],
        x[1] + y[1] + z[1]
    ];
}

function add4(x, y, z, w) {
    return [
        x[0] + y[0] + z[0] + w[0],
        x[1] + y[1] + z[1] + w[1]
    ];
}

function sub(x, y) {
    return [
        x[0] - y[0],
        x[1] - y[1]
    ];
}

function mul(x, y) {
    return [
        x[0] * y[0] - x[1] * y[1],
        x[0] * y[1] + x[1] * y[0]
    ];
}

function div(x, y) {
    const denom = y[0] * y[0] + y[1] * y[1];
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function divEpsilon(x, y, epsilon) {
    const denom = y[0] * y[0] + y[1] * y[1] + epsilon;
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function recip(z) {
    return div([1.0,0.0], z);
}

function scale(r, c) {
    return [
        r * c[0],
        r * c[1]
    ];
}

function cnorm(c) {
    return Math.hypot(c[0], c[1]);
}

function cnorm_squared(c) {
    return c[0] * c[0] + c[1] * c[1];
}

function touchmove() {
    event.preventDefault();
    for (let i = 0; i < event.changedTouches.length; i++) {
        const changedTouch = event.changedTouches[i];
        const ongoingTouch = touches.get(changedTouch.identifier);
        if (ongoingTouch) {
            ongoingTouch.pageX = changedTouch.pageX;
            ongoingTouch.pageY = changedTouch.pageY;
        }
    }

    if (touches.size === 1) {
        const offsetX = event.target.getBoundingClientRect().left;
        const offsetY = event.target.getBoundingClientRect().top;

        const touch0 = touches.get(params.touchStartId);
        if (!touch0) {
            return;
        }
        let x = (touch0.pageX - touch0.startX) / 200;
        let y = -(touch0.pageY - touch0.startY) / 200;

        let ascaled = mul(params.touchStartAScale, [x,y]);
        let bscaled = mul(params.touchStartBScale, [x,y]);
        if (params.drag === "zoom") {
            params.a = sub(params.touchStartA, ascaled);
            params.b = sub(params.touchStartB, bscaled);
        } else if (params.drag === "distort") {
            params.a[1] = params.touchStartA[1] - ascaled[1];
            params.b[1] = params.touchStartB[1] - bscaled[1];
        }

        // params.ascale[1] = params.touchStartAScale[1] - ascaled[1];
        // params.bscale[1] = params.touchStartBScale[1] - bscaled[1];

        repaint();
    }
    
    if (touches.size === 2) {
        const touch0 = touches.get(params.touchStartId);
        const touch1 = Array.from(touches.values()).find(t => t.identifier !== params.touchStartId);
        if (!touch0 || !touch1) {
            return;
        }

        let x0 = (touch0.pageX - touch0.startX) / 200;
        let y0 = -(touch0.pageY - touch0.startY) / 200;

        let x1 = (touch1.pageX - touch1.startX) / 200;
        let y1 = -(touch1.pageY - touch1.startY) / 200;

        let startd = [
            touch1.startX - touch0.startX,
            -(touch1.startY - touch0.startY)
        ];
        let endd = [
            touch1.pageX - touch0.pageX,
            -(touch1.pageY - touch0.pageY)
        ];
        let rotate = div(startd, endd);

        let ascaled = mul(params.touchStartAScale, [x0,y0]);
        let bscaled = mul(params.touchStartBScale, [x0,y0]);
        if (params.drag === "zoom") {
            params.a = sub(params.touchStartA, ascaled);
            params.b = sub(params.touchStartB, bscaled);
            params.ascale = mul(params.touchStartAScale, rotate);
            params.bscale = mul(params.touchStartBScale, rotate);
        }
        repaint();
    }
}

function repaint() {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    paint();
}

function scale_rotate(scaleX, scaleY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.mandelbrot) {
        if (params.drag === "ca") {
            let c0 = -params.ascale[0] - params.bscale[0];
            let c1 = -params.ascale[1] - params.bscale[1];
            let cincrx = c0 * scaleX - c1 * scaleY - c0;
            let cincry = c0 * scaleY + c1 * scaleX - c1;
            params.ascale[0] -= cincrx;
            params.ascale[1] -= cincry;
        }
        if (params.drag === "bc") {
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
        if (params.drag === "ab") {
            let aincrx = params.ascale[0] * scaleX - params.ascale[1] * scaleY - params.ascale[0];
            let aincry = params.ascale[0] * scaleY + params.ascale[1] * scaleX - params.ascale[1];
            params.ascale[0] += aincrx;
            params.ascale[1] += aincry;
            params.bscale[0] -= aincrx;
            params.bscale[1] -= aincry;
        }
        if (params.drag === "all") {
            params.ascale = [
                params.ascale[0] * scaleX - params.ascale[1] * scaleY,
                params.ascale[0] * scaleY + params.ascale[1] * scaleX
            ];
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
    } else {
        params.z0Scale /= scale;
    }
}

function move(deltaX, deltaY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.drag === "ca") {
        const cscale = [
            (scale[0] + params.bscale[0]),
            (params.ascale[1] + params.bscale[1])
        ];
        params.a[0] += deltaX * cscale[0] - deltaY * cscale[1];
        params.a[1] += deltaY * cscale[0] + deltaX * cscale[1];
    }
    if (params.drag === "bc") {
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
    if (params.drag === "ab") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] -= deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.b[1] -= deltaY * params.ascale[0] + deltaX * params.ascale[1];
    }
    if (params.drag === "all") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
}

function update_buttons() {
    document.getElementById("button_distort").classList.remove("active");
    document.getElementById("button_zoom").classList.remove("active");
    if (params.drag === "distort") {
        document.getElementById("button_distort").classList.add("active");
    } else if (params.drag === "zoom") {
        document.getElementById("button_zoom").classList.add("active");
    }
}


function csqrt(z) {
    const r = Math.sqrt(cnorm(z));
    const theta = Math.atan2(z[1], z[0]);
    return [
        r * Math.cos(theta / 2.0),
        r * Math.sin(theta / 2.0)
    ];
}

function other_csqrt(z) {
    const r = Math.sqrt(cnorm(z));
    const theta = Math.atan2(-z[1], -z[0]);
    return [
        -r * Math.sin(theta / 2.0),
        r * Math.cos(theta / 2.0)
    ];
}

function solve_quadratic(a, b, c) {
    const discriminant = csqrt(sub(mul(b, b), scale(4.0, mul(a, c))));
    const root1 = div(sub(discriminant, b), scale(2.0, a));
    return root1;
}

class Derivatives {
    constructor(value, d) {
        this.value = value;
        this.d = d;
    }

    static fromConstant(value) {
        return new Derivatives(value, [0.0, 0.0]);
    }

    static fromRealConstant(value) {
        return Derivatives.fromConstant([value, 0.0]);
    }

    static fromVar(v) {
        return new Derivatives(v, [1.0, 0.0]);
    }

    add(other) {
        return new Derivatives(
            add(this.value, other.value),
            add(this.d, other.d),
        );
    }

    sub(other) {
        return new Derivatives(
            sub(this.value, other.value),
            sub(this.d, other.d),
        );
    }

    scale(r) {
        return new Derivatives(
            scale(r, this.value),
            scale(r, this.d),
        );
    }

    mul(other) {
        return new Derivatives(
            mul(this.value, other.value),
            add(
                mul(this.d, other.value),
                mul(this.value, other.d)
            )
        );
    }

    recip() {
        const f = div([1.0, 0.0], this.value);
        const f1 = scale(-1, mul(f, f));
        return new Derivatives(
            f,
            mul(f1, this.d)
        );
    }

    square() {
        return this.mul(this);
    }

    div(other) {
        return this.mul(other.recip());
    }

    real_part() {
        return new RealDerivatives(this.value[0], [this.d[0], -this.d[1]]);
    }

    imag_part() {
        return new RealDerivatives(this.value[1], [this.d[1], this.d[0]]);
    }

    cnorm_squared() {
        return this.real_part().square().add(this.imag_part().square());
    }
}

class RealDerivatives {
    constructor(value, d) {
        this.value = value;
        this.d = d;
    }

    fromConstant(value) {
        return new RealDerivatives(value, 0, 0);
    }

    together_with(other) {
        // assumes this.value == other.value
        return new RealDerivatives(this.value, this.d.concat(other.d));
    }

    add(other) {
        let d = [];
        for (let i = 0; i < this.d.length; i++) {
            d.push(this.d[i] + other.d[i]);
        }
        return new RealDerivatives(
            this.value + other.value,
            d
        );
    }

    mul(other) {
        let d = [];
        for (let i = 0; i < this.d.length; i++) {
            d.push(this.d[i] * other.value + other.d[i] * this.value);
        }
        return new RealDerivatives(
            this.value * other.value,
            d,
        )
    }

    square() {
        return this.mul(this);
    }

    sqrt() {
        let v = Math.sqrt(this.value);
        let d = [];
        for (let i = 0; i < this.d.length; i++) {
            d.push(this.d[i] * 0.5 / v);
        }
        return new RealDerivatives(
            v,
            d
        )
    }
}

function target(x, y) {
    params.c = add(mul([x,y], params.cscale), params.ccenter);
    params.mandelbrot = false;
    gen_dots();
    repaint();
}

function direction_to_go(z) {
    let Z = Derivatives.fromZ(z);
    let C = Derivatives.fromC(params.c);
    for (let i = 0; i < 1000; i++) {
        Z = Z.square().add(C);
        if (cnorm(Z.value) > 1000) {
            break;
        }
    }
    return div(Z.value, Z.dz);
}

function gen_dots() {
    let c = params.c;
    let z = c;
    let prev = [0,0];

    params.plot_points = [];
    for (let i = 0; i < 500; i++) {
        let d = direction_to_go(z);
        z = add(z, scale(1, d));
        // let preimage = csqrt(sub(z, c));
        // if (cnorm(sub(prev,preimage)) > cnorm(add(prev,preimage))) {
        //     preimage = scale(-1, preimage);
        // }
        // prev = preimage;
        params.plot_points.push(div(sub(z, params.z0), params.z0Scale));
        if (cnorm(z) > 1000) {
            break;
        }
    }
}

function mandelbrot_direction_to_go(c,target,target_iter) {
    let Z = Derivatives.fromZ(c);
    Z.dc = [1,0];
    let C = Derivatives.fromC(c);
    for (let i = 0; i < target_iter; i++) {
        Z = Z.square().add(C);
    }
    return {d:div(sub(Z.value, target), Z.dc), warning:cnorm(Z.value) > 1000};
}

function scale_mandelbrot_dots() {
    params.plot_points = [];
    for (let i = 0; i < params.unscaled_points.length; i++) {
        params.plot_points.push(div(sub(params.unscaled_points[i], params.ccenter), params.cscale));
    }
}

const palette = [
    [1,0,0],
    [0,1,0],
    [1,1,0],
    [0,0,1],
    [1,0,1],
    [0,1,1],
    [1,0.5,0],
    [0.7,0.5,1],
    [1,0,0],
]

function iterate(z, c, n) {
    for (let i = 0; i < n; i++) {
        z = z.square().add(c);
    }
    return z;
}

function iterate_dash(z, c, n) {
    let prod = Derivatives.fromRealConstant(1);
    for (let i = 0; i < n; i++) {
        z = z.square().add(c);
        prod = prod.mul(z.scale(2));
    }
    return prod;
}

function find_root(n, t, z0, c0) {
    let z = z0;
    let c = c0;
    for (let i = 0; i < 1000; i++) {
        // params.unscaled_points.push(c);
        // params.plot_colors.push([1,0,0]);
        let itz = iterate(Derivatives.fromVar(z), Derivatives.fromConstant(c), n).sub(Derivatives.fromVar(z));
        let itc = iterate(Derivatives.fromConstant(z), Derivatives.fromVar(c), n).sub(Derivatives.fromConstant(z));
        let fz = iterate_dash(Derivatives.fromVar(z), Derivatives.fromConstant(c), n).sub(Derivatives.fromConstant(t));
        let fc = iterate_dash(Derivatives.fromConstant(z), Derivatives.fromVar(c), n).sub(Derivatives.fromConstant(t));
        
        let lossz = itz.cnorm_squared().add(fz.cnorm_squared());
        let lossc = itc.cnorm_squared().add(fc.cnorm_squared());
        let loss = lossz.together_with(lossc).sqrt();
        // console.log(loss.value, z, c, loss.d, itz.value, fz.value);
        let epsilon = 0.002;
        z = [z[0] - epsilon * loss.d[0], z[1] - epsilon * loss.d[1]];
        c = [c[0] - epsilon * loss.d[2], c[1] - epsilon * loss.d[3]];
    }
    return c;
}

function find_roots(n, num_roots) {
    let t = [0.0, 0.0];
    let roots = [];
    for (let i = 0; i < num_roots; i++) {
        let c = Derivatives.fromVar([0.0, 2.0]);
        for (let i = 0; i < 20; i++) {
            let z = Derivatives.fromRealConstant(0.0);
            for (let j = 0; j < n; j++) {
                z = z.square().add(c);
            }

            for (let j = 0; j < roots.length; j++) {
                z = z.div(c.sub(Derivatives.fromConstant(roots[j])));
            }
            c.value = add(c.value, div(sub(t, z.value), z.d));
        }
        if (Number.isNaN(c.value[0]) || Number.isNaN(c.value[1])) {
            // give up if it's giving NaNs
            break;
        }
        roots.push(c.value);
    }
    return roots;
}

function trace_from(root, n, epsilon) {
    let c = Derivatives.fromVar(root);
    let t = [0.0, 0.0];
    for (let i = 0; i < 200; i++) {
        params.unscaled_points.push(c.value);
        params.plot_colors.push(palette[A-1]);
        let z = Derivatives.fromRealConstant(0.0);
        for (let j = 0; j < n; j++) {
            z = z.square().add(c);
        }
        c.value = add(c.value, divEpsilon(sub(t, z.value), z.d, 0.0001));
        const cs = other_csqrt(c.value);
        const len = cnorm(cs);
        t = add(t, scale(epsilon / len, cs));
    }
}

function gen_mandelbrot_dots2() {
    params.unscaled_points = [];

    // let roots = find_roots(A, 1<<(A-1));
    let roots = [];
    for (let i = 0; i < 10; i++) {
        roots.push(find_root(A, [1,0], [Math.random()*2-1, Math.random()-.5], [Math.random()*2-1.5, Math.random()-.5]));
    }
    console.log("Roots", roots);

    for (let r = 0; r < roots.length; r++) {
        params.unscaled_points.push(roots[r]);
        params.plot_colors.push(palette[A-1]);
        // trace_from(roots[r], A, 0.01);
        // trace_from(roots[r], A, -0.01);
    }
    scale_mandelbrot_dots();
}

function gen_mandelbrot_dots() {
    let theta = 0;
    params.unscaled_points = [];
    let done = [];
    for (let j = 0; j <= Math.min(Math.max(A,B)+1, palette.length); j++) {
        if (j+1 < A || j+1 > B) {
            continue;
        }
        let denom = Math.pow(2, j + 1) - 1;
        for (let num = 0; num < denom; num++) {
            if (done.indexOf(num / denom) !== -1) {
                continue;
            }
            done.push(num / denom);
            const theta = 6.28318530718 * num / denom;
            let c = scale(50, [Math.cos(theta),Math.sin(theta)]);
            let target = c;
            let target_iter = 0;
            for (let i = 0; i < 2000; i++) {
                let {d,warning} = mandelbrot_direction_to_go(c,target,target_iter);
                c = sub(c, d);
                target = scale(0.9, target);
                if (cnorm(target) < 50) {
                    target = mul(target,target);
                    target_iter += 1;
                }
                if (target_iter > j) {
                    params.unscaled_points.push(c);
                    params.plot_colors.push(palette[j]);
                }
            }
        }
    }
    scale_mandelbrot_dots();
}

function gen_svg2() {
    let points = [
        {num:0, denom:1, j:0, x:0.5, y:1},
        {num:1, denom:1, j:0, x:0.5, y:-1},
    ];
    // created sorted array of values
    for (let j = 1; j < 8; j++) {
        let denom = Math.pow(2, j+1) - 1;
        for (let num = 0; num < denom; num++) {
            let found = false;
            for (let i = 0; i < points.length; i++) {
                if (points[i].num * denom === num * points[i].denom) {
                    // they're the same
                    found = true;
                }
            }
            if (!found) {
                const theta = num / denom * 6.28318530718;
                points.push({num, denom, j});
            }
        }
    }
    points.sort((a,b) => a.num * b.denom - b.num * a.denom);

    let stack = [];
    for (let i = 0; i < points.length; i++) {
        stack.push(i);
        if (stack.length >= 2 && points[stack[stack.length-1]].j === points[stack[stack.length-2]].j) {
            const i0 = stack.pop();
            const i1 = stack.pop();
            points[i0].partner = i1;
            points[i1].partner = i0;
        }
    }

    let prevs = {};
    for (let i = 0; i < points.length; i++) {
        prevs[points[i].j] = i;
        if (points[i].j === 0) {
            continue;
        }
        let maximum = -1;
        for (let j = 0; j < points[i].j; j++) {
            if (prevs[j] > maximum) {
                maximum = prevs[j];
            }
        }
        points[i].prev = maximum;
        if (maximum === -1) {
            throw `Unexpected ${i}`;
        }
    }
    prevs = undefined;

    let nexts = {};
    for (let i = points.length-1; i >= 0; i--) {
        nexts[points[i].j] = i;
        if (points[i].j === 0) {
            continue;
        }
        let minimum = points.length;
        for (let j = 0; j < points[i].j; j++) {
            if (nexts[j] < minimum) {
                minimum = nexts[j];
            }
        }
        points[i].next = minimum;
        if (minimum === points.length) {
            throw `Unexpected ${i}`;
        }
    }

    for (let i = 1; i < points.length-1; i++) {
        const p = points[i];
        console.log(`${p.num}/${p.denom}: partner=${points[p.partner].num}/${points[p.partner].denom}   prev=${points[p.prev].num}/${points[p.prev].denom}   next=${points[p.next].num}/${points[p.next].denom}`);
    }

    for (let j = 1; j < 8; j++) {
        for (let i = 0; i < points.length; i++) {
            if (points[i].j !== j) {
                continue;
            }

            const p = points[points[i].prev];
            const pp = points[p.partner];
            const n = points[points[i].next];
            const np = points[n.partner];

            const ppinch = Math.pow(0.5, points[i].j - p.j);
            const npinch = Math.pow(0.5, points[i].j - n.j);
            const x0 = (p.x + pp.x + ppinch * (p.x - pp.x)) / 2;
            const y0 = (p.y + pp.y + ppinch * (p.y - pp.y)) / 2;
            const x1 = (n.x + np.x + npinch * (n.x - np.x)) / 2;
            const y1 = (n.y + np.y + npinch * (n.y - np.y)) / 2;
            
            if (p.partner === points[i].next) {
                const dist = 0.7;
                if (points[i].partner > i) {
                    points[i].x = x0 - dist * (y0 - y1);
                    points[i].y = y0 + dist * (x0 - x1);
                } else {
                    points[i].x = x1 + dist * (y1 - y0);
                    points[i].y = y1 - dist * (x1 - x0);
                }
            } else {
                const dist = 0.5;
                const x0b = (x0 * 2 + x1) / 3;
                const y0b = (y0 * 2 + y1) / 3;
                const x1b = (x1 * 2 + x0) / 3;
                const y1b = (y1 * 2 + y0) / 3;
                if (points[i].partner > i) {
                    points[i].x = x0b - dist * (y0b - y1b);
                    points[i].y = y0b + dist * (x0b - x1b);
                } else {
                    points[i].x = x1b + dist * (y1b - y0b);
                    points[i].y = y1b - dist * (x1b - x0b);
                }
            }
        }
    }

    const size = 300;
    const svg = document.getElementById("svg2");
    for (let i = 0; i < points.length; i++) {
        if (points[i].j >= 8) {
            continue;
        }
        if (points[i].partner < i) {
            continue;
        }
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        const j = points[i].j;
        line.setAttribute("x1", 400 + size * points[i].x);
        line.setAttribute("y1", 400 + size * points[i].y);
        line.setAttribute("x2", 400 + size * points[points[i].partner].x);
        line.setAttribute("y2", 400 + size * points[points[i].partner].y);
        line.setAttribute("stroke", `rgb(${255*palette[j][0]},${255*palette[j][1]},${255*palette[j][2]})`);
        svg.appendChild(line);
    }
}

function gen_svg() {
    let points = [
        {num:0, denom:1, j:0, cx: 0, cy: 0, cr: 1, theta: 0},
        {num:1, denom:1, j:0, cx: 0, cy: 0, cr: 1, theta: 0},
    ];
    // created sorted array of values
    for (let j = 1; j < 8; j++) {
        let denom = Math.pow(2, j+1) - 1;
        for (let num = 0; num < denom; num++) {
            let found = false;
            for (let i = 0; i < points.length; i++) {
                if (points[i].num * denom === num * points[i].denom) {
                    // they're the same
                    found = true;
                }
            }
            if (!found) {
                points.push({num, denom, j, cx:0,cy:0,cr:1,theta: num/denom*6.28318530718});
            }
        }
    }
    points.sort((a,b) => b.num * a.denom - a.num * b.denom);

    const svg = document.getElementById("svg");
    svg.innerHTML = "";
    const size = 400;

    let stack = [];
    for (let i = 0; i < points.length; i++) {
        stack.push(points[i]);
        if (stack.length >= 2 && stack[stack.length-1].j === stack[stack.length-2].j) {
            const p0 = stack.pop();
            const p1 = stack.pop();
            const j = p1.j;
            
            const x0 = size * (1 + p0.cx + p0.cr * Math.cos(p0.theta));
            const y0 = size * (1 + p0.cy + p0.cr * Math.sin(p0.theta));
            const x1 = size * (1 + p1.cx + p1.cr * Math.cos(p1.theta));
            const y1 = size * (1 + p1.cy + p1.cr * Math.sin(p1.theta));
            const r = Math.pow(Math.hypot(x1 - x0, y1 - y0)/size, 1.2) * size;
            const arc = document.createElementNS("http://www.w3.org/2000/svg", "path");
            arc.setAttribute("d", `M ${x0} ${y0} A ${r} ${r} ${(p0.theta+p1.theta)/2} 0 0 ${x1} ${y1}`);
            arc.setAttribute("fill", "transparent");
            arc.setAttribute("stroke-width", "2px");
            arc.setAttribute("stroke", `rgb(${255*palette[j][0]},${255*palette[j][1]},${255*palette[j][2]})`);

            svg.appendChild(arc);
        }
    }
}

function start() {
    glStuff = setup();
    update_buttons();
    if (showDots) {
        gen_mandelbrot_dots2();
    }
    paint();
}

window.onload = start;
    </script>
    <style>
button {
    padding: 10px;
}
button.active {
    background: #ffaaaa;
}
    </style>
</head>
<body>
    <button id="button_zoom" onclick="params.drag='zoom'; update_buttons()">Zoom</button>
    <button id="button_distort" onclick="params.drag='distort'; update_buttons()">Distort</button>
    <br>
    <canvas id="canvas" width="2000" height="1400" onmousedown="mousedown()" onmousemove="mousemove()" onwheel="mousewheel()" ontouchstart="touchstart()" ontouchmove="touchmove()" ontouchend="touchend()"></canvas>
</body>
</html>