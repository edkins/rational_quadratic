<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

let params = {
    fixedPoints: [
        [1.0, 0.0],
        [-0.5, Math.sqrt(3)/2],
        [-0.5, -Math.sqrt(3)/2]
    ],
    center: [0.0, 0.0],
    scale: 0.5,
};
let glStuff = null;
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.0, 0.0, 1.0);

    // Vertex Shader program - mark fixed points
    const vsSourcePoints = `
        attribute vec3 aVertexPosition;
        uniform vec2 uCenter;
        uniform float uScale;
        uniform vec2 uPoint;
        uniform vec2 a;
        uniform vec2 b;
        uniform vec2 c;
        void main(void) {
            gl_Position = vec4(
                (a * aVertexPosition.x + b * aVertexPosition.y + c * aVertexPosition.z) * uScale + uCenter,
                0.0,
                1.0);
            gl_PointSize = 5.0;
        }
    `;
    // Fragment Shader program - mark fixed points
    const fsSourcePoints = `
        precision mediump float;
        void main(void) {
            gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
        }
    `;

    // Vertex shader program
    const vsSource = `
        precision mediump float;
        attribute vec2 aVertexPosition;
        uniform vec2 uCenter;
        uniform float uScale;
        uniform vec2 a;
        uniform vec2 b;
        uniform vec2 c;
        varying vec2 vPosition;
        varying vec2 A;
        varying vec2 B;
        varying vec2 C;
        varying vec2 D;
        varying vec2 E;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vPosition = (aVertexPosition - uCenter) / uScale;
            A = vec2(0.0, 0.0);
            D = -(a + b + c);
            B = vec2(0.0, 0.0);
            E = mul(a, b) + mul(a, c) + mul(b, c);
            C = -mul(a, mul(b, c));
        }
    `;
    // Fragment shader program
    const fsSource = `
        precision mediump float;
        uniform vec2 a;
        uniform vec2 b;
        uniform vec2 c;
        varying vec2 vPosition;
        varying vec2 A;
        varying vec2 B;
        varying vec2 C;
        varying vec2 D;
        varying vec2 E;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        void main(void) {
            vec2 z = vPosition;
            const int max_iteration = 100;
            int iter = 0;
            for (int iteration = 0; iteration < max_iteration; iteration++) {
                vec2 z2 = mul(z, z);
                z = div(
                    mul(A, z2) + mul(B, z) + C,
                    z2 + mul(D, z) + E
                );
                if (length(z - a) < 0.1 || length(z - b) < 0.1 || length(z - c) < 0.1) {
                    break;
                }
                iter++;
            }
            float color = 1.0 - float(iter) / float(max_iteration);
            gl_FragColor = vec4(color, color, color, 1.0);
        }
    `;
    // Initialize shaders
    const vertexShaderPoints = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderPoints, vsSourcePoints);
    ctx.compileShader(vertexShaderPoints);
    const fragmentShaderPoints = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderPoints, fsSourcePoints);
    ctx.compileShader(fragmentShaderPoints);
    const shaderProgramPoints = ctx.createProgram();
    ctx.attachShader(shaderProgramPoints, vertexShaderPoints);
    ctx.attachShader(shaderProgramPoints, fragmentShaderPoints);
    ctx.linkProgram(shaderProgramPoints);

    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);
    ctx.useProgram(shaderProgram);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    // Set up point vertices
    const pointVertices = new Float32Array([
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
    ]);
    const vertexBufferPoints = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBufferPoints);
    ctx.bufferData(ctx.ARRAY_BUFFER, pointVertices, ctx.STATIC_DRAW);

    return {
        shaderProgram,
        shaderProgramPoints,
        aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
        uCenter: ctx.getUniformLocation(shaderProgram, "uCenter"),
        uScale: ctx.getUniformLocation(shaderProgram, "uScale"),
        ua: ctx.getUniformLocation(shaderProgram, "a"),
        ub: ctx.getUniformLocation(shaderProgram, "b"),
        uc: ctx.getUniformLocation(shaderProgram, "c"),
        vertexBuffer,
        vertexBufferPoints,
        uCenterPoints: ctx.getUniformLocation(shaderProgramPoints, "uCenter"),
        uScalePoints: ctx.getUniformLocation(shaderProgramPoints, "uScale"),
        uaPoints: ctx.getUniformLocation(shaderProgramPoints, "a"),
        ubPoints: ctx.getUniformLocation(shaderProgramPoints, "b"),
        ucPoints: ctx.getUniformLocation(shaderProgramPoints, "c"),
    };
}

function paint(stuff) {
    const ctx = document.getElementById("canvas").getContext("webgl");
    ctx.clear(ctx.COLOR_BUFFER_BIT);
    
    // Draw the square
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform2f(stuff.uCenter, params.center[0], params.center[1]);
    ctx.uniform1f(stuff.uScale, params.scale);
    ctx.uniform2f(stuff.ua, params.fixedPoints[0][0], params.fixedPoints[0][1]);
    ctx.uniform2f(stuff.ub, params.fixedPoints[1][0], params.fixedPoints[1][1]);
    ctx.uniform2f(stuff.uc, params.fixedPoints[2][0], params.fixedPoints[2][1]);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
    
    // Draw the points
    ctx.useProgram(stuff.shaderProgramPoints);
    ctx.uniform2f(stuff.uCenterPoints, params.center[0], params.center[1]);
    ctx.uniform1f(stuff.uScalePoints, params.scale);
    ctx.uniform2f(stuff.uaPoints, params.fixedPoints[0][0], params.fixedPoints[0][1]);
    ctx.uniform2f(stuff.ubPoints, params.fixedPoints[1][0], params.fixedPoints[1][1]);
    ctx.uniform2f(stuff.ucPoints, params.fixedPoints[2][0], params.fixedPoints[2][1]);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBufferPoints);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 3, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.POINTS, 0, 3);
}


function mousedown() {
    const x = event.clientX;
    const y = event.clientY;
    update_point(x,y);
}

function mousemove() {
    if (event.buttons === 1) {
        const x = event.clientX;
        const y = event.clientY;
        update_point(x, y);
    }
}

function update_point(x, y) {
    const rect = event.target.getBoundingClientRect();
    const canvasX = x - rect.left;
    const canvasY = y - rect.top;
    const ndcX = (canvasX / rect.width) * 2 - 1;
    const ndcY = 1 - (canvasY / rect.height) * 2
    params.fixedPoints[0] = [
        ndcX / params.scale - params.center[0],
        ndcY / params.scale - params.center[1]
    ];
    paint(glStuff);
}

function start() {
    glStuff = setup();
    paint(glStuff);
}

window.onload = start;
    </script>
</head>
<body>
    <canvas id="canvas" width="800" height="800" onmousedown="mousedown()" onmousemove="mousemove()"></canvas>
</body>
</html>