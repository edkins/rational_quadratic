<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

let params = {
    a: [0.3, 0.1],
    ascale: [0.0, 0.2],
    b: [0.3, -0.1],
    bscale: [0.25, 0.0],
    z0: [0.0, 0.0],
    z0Scale: 2.0,
    mandelbrot: true,
    color: true,
    drag: "zoom",
    drag_start: [0.0, 0.0],
    timer: null,
    last_moved: 0,
    high_count: 0,
    touchStartA: null,
    touchStartB: null,
    touchStartAScale: null,
    touchStartBScale: null,
    touchSide: null,
    touchStartId: null,
    plot_points: [],
};
let glStuff = null;
let touches = new Map();

function fragmentShaderSource(max_iter, max_period) {
    return `
        precision highp float;
        varying vec2 a;
        varying vec2 b;
        varying vec2 z0;
        uniform bool uMandelbrot;
        uniform float uBailout;
        uniform float uBailin;
        uniform float uBrightness;

        const vec2 two = vec2(2.0, 0.0);
        const vec2 one = vec2(1.0, 0.0);

        vec2 csqrt(vec2 z) {
            float r = length(z);
            float theta = atan(z.y, z.x);
            return vec2(
                sqrt(r) * cos(theta / 2.0),
                sqrt(r) * sin(theta / 2.0)
            );
        }

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        vec2 solve_quadratic(vec2 a, vec2 b, vec2 c) {
            float ftheta = 2.0; // move branch cut
            vec2 fudge = vec2(cos(ftheta), sin(ftheta));
            vec2 fudge2 = div(one, mul(fudge, fudge));
            vec2 discriminant = -mul(fudge, csqrt(mul(fudge2, mul(b, b) - 4.0 * mul(a, c))));
            vec2 root1 = div(-b + discriminant, 2.0 * a);
            return root1;
        }

        vec4 mandelbrot(vec2 actual_z0) {
            vec2 z = actual_z0;
            const int max_iteration = ${max_iter};
            int iter = 0;
            vec2 prevZ = z;
            int brightness = 0;
            int period = -1;
            float distance = 10000.0;
            for (int iteration = 0; iteration < max_iteration; iteration++) {
                vec2 z2 = mul(z, z);
                z = div(
                    mul(a, z2) + mul(b - one, z),
                    mul(a - one, z) + b
                );
                if (length(z) > uBailout) {
                    break;
                }

                float d = length(z - actual_z0);
                if (d < distance) {
                    distance = d;
                    period = iteration;
                }
            }
            float brightnessf = 0.5 + distance;
            float theta = float(period) * 3.88;
            if (period == -1) {
                return vec4(5.0 * brightnessf, 5.0 * brightnessf, 5.0 * brightnessf, 1.0);
            }
            vec3 color = vec3(1.0 + cos(theta), 1.0 + cos(theta + 2.1), 1.0 + cos(theta + 4.2)) * brightnessf;
            return vec4(color, 1.0);
        }

        void main(void) {
            if (uMandelbrot) {
                vec2 root = solve_quadratic(
                    mul(a, a - one),
                    2.0 * mul(a, b),
                    mul(b, b - one)
                );
                gl_FragColor = mandelbrot(root);
            } else {
                gl_FragColor = mandelbrot(z0);
            }
        }
    `;
}
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.9, 0.9, 1.0);

    // Mandelbrot vertex shader program
    const vsSource = `
        precision highp float;
        attribute vec2 aVertexPosition;
        uniform vec2 uz0;
        uniform float uz0Scale;
        uniform vec2 ua;
        uniform vec2 ub;
        uniform vec2 uascale;
        uniform vec2 ubscale;
        uniform vec2 uNudge;
        varying vec2 a;
        varying vec2 b;
        varying vec2 z0;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vec2 vp = aVertexPosition * vec2(1.0, 2.0) + uNudge;
            a = ua + mul(vp, uascale);
            b = ub + mul(vp, ubscale);
            z0 = uz0 + vp * uz0Scale;
        }
    `;

    // Mandelbrot/Julia fragment shader program
    const fsSource = fragmentShaderSource(200, 32);
    const fsSourceHigh = fragmentShaderSource(2000, 100);

    // Initialize shaders
    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);

    // Initialize shaders (high iteration count)
    const fragmentShaderHigh = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderHigh, fsSourceHigh);
    ctx.compileShader(fragmentShaderHigh);
    if (!ctx.getShaderParameter(fragmentShaderHigh, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the high iteration shader: " +
            ctx.getShaderInfoLog(fragmentShaderHigh));
        return null;
    }
    const shaderProgramHigh = ctx.createProgram();
    ctx.attachShader(shaderProgramHigh, vertexShader);
    ctx.attachShader(shaderProgramHigh, fragmentShaderHigh);
    ctx.linkProgram(shaderProgramHigh);

    // Shaders for texture blitting
    const vsSourceBlit = `
        attribute vec2 aVertexPosition;
        varying vec2 vTexCoord;
        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vTexCoord = (aVertexPosition + vec2(1.0, 1.0)) * 0.5;
        }
    `;
    const fsSourceBlit = `
        precision highp float;
        varying vec2 vTexCoord;
        uniform sampler2D uTexture;
        void main(void) {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;
    const vertexShaderBlit = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderBlit, vsSourceBlit);
    ctx.compileShader(vertexShaderBlit);
    const fragmentShaderBlit = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderBlit, fsSourceBlit);
    ctx.compileShader(fragmentShaderBlit);
    if (!ctx.getShaderParameter(vertexShaderBlit, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderBlit, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the blit shaders: " +
            ctx.getShaderInfoLog(vertexShaderBlit) + " " +
            ctx.getShaderInfoLog(fragmentShaderBlit));
        return null;
    }
    const shaderProgramBlit = ctx.createProgram();
    ctx.attachShader(shaderProgramBlit, vertexShaderBlit);
    ctx.attachShader(shaderProgramBlit, fragmentShaderBlit);
    ctx.linkProgram(shaderProgramBlit);

    // Shaders for point markers
    const vsSourcePoint = `
        precision highp float;
        uniform vec2 uVertexPosition;
        uniform float uPointSize;
        void main(void) {
            gl_Position = vec4(uVertexPosition * vec2(1.0, 0.5), 0.0, 1.0);
            gl_PointSize = uPointSize;
        }
    `;
    const fsSourcePoint = `
        precision highp float;
        uniform vec3 uColor;
        void main(void) {
            gl_FragColor = vec4(uColor, 1.0);
        }
    `;
    const vertexShaderPoint = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderPoint, vsSourcePoint);
    ctx.compileShader(vertexShaderPoint);
    const fragmentShaderPoint = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderPoint, fsSourcePoint);
    ctx.compileShader(fragmentShaderPoint);
    if (!ctx.getShaderParameter(vertexShaderPoint, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderPoint, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the point shaders: " +
            ctx.getShaderInfoLog(vertexShaderPoint) + " " +
            ctx.getShaderInfoLog(fragmentShaderPoint));
        return null;
    }
    const shaderProgramPoint = ctx.createProgram();
    ctx.attachShader(shaderProgramPoint, vertexShaderPoint);
    ctx.attachShader(shaderProgramPoint, fragmentShaderPoint);
    ctx.linkProgram(shaderProgramPoint);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    // Create texture to hold low-iteration Mandelbrot image
    const fbWidth = 400;
    const fbHeight = 800;
    const destTexture = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTexture);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidth, fbHeight, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render low-iteration Mandelbrot image into
    const framebuffer = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffer);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTexture, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    // Create texture to hold high-iteration Mandelbrot image
    const fbWidthHigh = 400;
    const fbHeightHigh = 800;
    const destTextureHigh = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTextureHigh);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidthHigh, fbHeightHigh, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render high-iteration Mandelbrot image into
    const framebufferHigh = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebufferHigh);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTextureHigh, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    return {
        main: {
            shaderProgram,
            aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgram, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgram, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgram, "uz0Scale"),
            ua: ctx.getUniformLocation(shaderProgram, "ua"),
            ub: ctx.getUniformLocation(shaderProgram, "ub"),
            uascale: ctx.getUniformLocation(shaderProgram, "uascale"),
            ubscale: ctx.getUniformLocation(shaderProgram, "ubscale"),
            uBailout: ctx.getUniformLocation(shaderProgram, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgram, "uBailin"),
            bailin: 0.002,
            bailout: 1000,
            uNudge: ctx.getUniformLocation(shaderProgram, "uNudge"),
            vertexBuffer,
            destTexture,
            framebuffer,
            fbWidth,
            fbHeight,
            uBrightness: ctx.getUniformLocation(shaderProgram, "uBrightness"),
            brightness: 0.02,
        },
        high: {
            shaderProgram: shaderProgramHigh,
            aVertexPosition: ctx.getAttribLocation(shaderProgramHigh, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgramHigh, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgramHigh, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgramHigh, "uz0Scale"),
            ua: ctx.getUniformLocation(shaderProgramHigh, "ua"),
            ub: ctx.getUniformLocation(shaderProgramHigh, "ub"),
            uascale: ctx.getUniformLocation(shaderProgramHigh, "uascale"),
            ubscale: ctx.getUniformLocation(shaderProgramHigh, "ubscale"),
            uBailout: ctx.getUniformLocation(shaderProgramHigh, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgramHigh, "uBailin"),
            bailin: 0.001,
            bailout: 1000,
            uNudge: ctx.getUniformLocation(shaderProgramHigh, "uNudge"),
            vertexBuffer,
            destTexture: destTextureHigh,
            framebuffer: framebufferHigh,
            fbWidth: fbWidthHigh,
            fbHeight: fbHeightHigh,
            uBrightness: ctx.getUniformLocation(shaderProgramHigh, "uBrightness"),
            brightness: 0.02,
        },
        blit: {
            shaderProgram: shaderProgramBlit,
            aVertexPosition: ctx.getAttribLocation(shaderProgramBlit, "aVertexPosition"),
            uTexture: ctx.getUniformLocation(shaderProgramBlit, "uTexture"),
            vertexBuffer,
        },
        point: {
            shaderProgram: shaderProgramPoint,
            uVertexPosition: ctx.getUniformLocation(shaderProgramPoint, "uVertexPosition"),
            uPointSize: ctx.getUniformLocation(shaderProgramPoint, "uPointSize"),
            uColor: ctx.getUniformLocation(shaderProgramPoint, "uColor"),
        }
    };
}

function paintMandelbrot(ctx, stuff, nudgeX, nudgeY) {
    // Draw the Julia or Mandelbrot set
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform1f(stuff.uBailout, stuff.bailout);
    ctx.uniform1f(stuff.uBailin, stuff.bailin);
    ctx.uniform2f(stuff.uNudge, nudgeX, nudgeY);
    if (params.mandelbrot) {
        ctx.uniform1i(stuff.uMandelbrot, true);
        ctx.uniform1f(stuff.uz0Scale, 0.0);
        ctx.uniform2f(stuff.ua, params.a[0], params.a[1]);
        ctx.uniform2f(stuff.uascale, params.ascale[0], params.ascale[1]);
        ctx.uniform2f(stuff.ub, params.b[0], params.b[1]);
        ctx.uniform2f(stuff.ubscale, params.bscale[0], params.bscale[1]);
        ctx.uniform1f(stuff.uBrightness, stuff.brightness);
    } else {
        ctx.uniform1i(stuff.uMandelbrot, false);
        ctx.uniform1f(stuff.uz0Scale, params.z0Scale);
        ctx.uniform2f(stuff.ua, params.a[0], params.a[1]);
        ctx.uniform2f(stuff.ub, params.b[0], params.b[1]);
        ctx.uniform2f(stuff.uascale, 0.0, 0.0);
        ctx.uniform2f(stuff.ubscale, 0.0, 0.0);
        ctx.uniform2f(stuff.uz0, params.z0[0], params.z0[1]);
        ctx.uniform1f(stuff.uBrightness, stuff.brightness);
    }
    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
}

function blit_texture(ctx, stuff, texture) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.activeTexture(ctx.TEXTURE0);
    ctx.bindTexture(ctx.TEXTURE_2D, texture);
    ctx.uniform1i(stuff.uTexture, 0);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);

    ctx.bindTexture(ctx.TEXTURE_2D, null);
}

function draw_dots(ctx, stuff) {
    for (const pt of params.plot_points) {
        ctx.useProgram(stuff.shaderProgram);
        ctx.uniform2f(stuff.uVertexPosition, pt[0], pt[1]);
        ctx.uniform1f(stuff.uPointSize, 10.0);
        ctx.uniform3f(stuff.uColor, 0, 0, 1);
        ctx.drawArrays(ctx.POINTS, 0, 1);
    }
}

function paint() {
    const ctx = document.getElementById("canvas").getContext("webgl");
    if (params.high_count === 0) {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.main.framebuffer);
        ctx.viewport(0, 0, glStuff.main.fbWidth, glStuff.main.fbHeight);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        paintMandelbrot(ctx, glStuff.main, 0, 0);

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        blit_texture(ctx, glStuff.blit, glStuff.main.destTexture);
        draw_dots(ctx, glStuff.point);

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        params.high_count += 1;
        params.timer = setTimeout(paint, 300);
    } else {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.high.framebuffer);
        ctx.viewport(0, 0, glStuff.high.fbWidth, glStuff.high.fbHeight);

        if (params.high_count === 1) {
            ctx.clear(ctx.COLOR_BUFFER_BIT);
            paintMandelbrot(ctx, glStuff.high, 0, 0);
        } else {
            ctx.enable(ctx.BLEND);
            ctx.blendEquation(ctx.FUNC_ADD);
            ctx.blendFuncSeparate(ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA, ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA);
            ctx.blendColor(1.0, 1.0, 1.0, 1.0 / params.high_count);
            let nudgeX = (Math.random() - 0.5) * 0.5 / 100;
            let nudgeY = (Math.random() - 0.5) * 0.5 / 100;
            paintMandelbrot(ctx, glStuff.high, nudgeX, nudgeY);
            ctx.disable(ctx.BLEND);
        }

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        blit_texture(ctx, glStuff.blit, glStuff.high.destTexture);
        draw_dots(ctx, glStuff.point);

        params.high_count += 1;

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        if (params.high_count < 8) {
            params.timer = setTimeout(paint, 100);
        }
    }
}

function mousedown() {
    const x = event.clientX;
    const y = event.clientY;
    const originX = event.target.getBoundingClientRect().left;
    const originY = event.target.getBoundingClientRect().top;
    const xy = [
        (x - originX) / 200 - 1,
        -(y - originY) / 200 + 2
    ];
    target(xy[0], xy[1]);
}

function mousemove() {
}

function mousewheel() {
}

function touchstart() {
    event.preventDefault();
    for (const changedTouch of event.changedTouches) {
        if (touches.size === 0) {
            const offsetX = event.target.getBoundingClientRect().left;
            const offsetY = event.target.getBoundingClientRect().top;
            const x = (changedTouch.pageX - offsetX) / 200 - 1;
            const y = -(changedTouch.pageY - offsetY) / 200 + 2;

            const aVal = add(params.a, mul([x, y], params.ascale));
            const bVal = add(params.b, mul([x, y], params.bscale));
            const cVal = sub([1.0, 0.0], add(aVal, bVal));
            if (aVal > bVal && aVal > cVal) {
                params.touchSide = "a";
            } else if (bVal > cVal) {
                params.touchSide = "b";
            } else {
                params.touchSide = "c";
            }
            params.touchStartId = changedTouch.identifier;
        }

        const touch = {
            pageX: changedTouch.pageX,
            pageY: changedTouch.pageY,
            // startX: changedTouch.pageX,
            // startY: changedTouch.pageY,
            identifier: changedTouch.identifier,
        };

        touches.set(changedTouch.identifier, touch);
    }

    params.touchStartA = [params.a[0], params.a[1]];
    params.touchStartB = [params.b[0], params.b[1]];
    params.touchStartAScale = [params.ascale[0], params.ascale[1]];
    params.touchStartBScale = [params.bscale[0], params.bscale[1]];
    for (const touch of touches.values()) {
        touch.startX = touch.pageX;
        touch.startY = touch.pageY;
    }
}

function touchend() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];
    const ongoingTouch = touches.get(changedTouch.identifier);
    const deltaX = changedTouch.pageX - ongoingTouch.pageX;
    const deltaY = changedTouch.pageY - ongoingTouch.pageY;
    touches.delete(changedTouch.identifier);
}

function add(x, y) {
    return [
        x[0] + y[0],
        x[1] + y[1]
    ];
}

function add3(x, y, z) {
    return [
        x[0] + y[0] + z[0],
        x[1] + y[1] + z[1]
    ];
}

function add4(x, y, z, w) {
    return [
        x[0] + y[0] + z[0] + w[0],
        x[1] + y[1] + z[1] + w[1]
    ];
}

function sub(x, y) {
    return [
        x[0] - y[0],
        x[1] - y[1]
    ];
}

function mul(x, y) {
    return [
        x[0] * y[0] - x[1] * y[1],
        x[0] * y[1] + x[1] * y[0]
    ];
}

function div(x, y) {
    const denom = y[0] * y[0] + y[1] * y[1];
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function scale(r, c) {
    return [
        r * c[0],
        r * c[1]
    ];
}

function cnorm(c) {
    return Math.hypot(c[0], c[1]);
}

function touchmove() {
    event.preventDefault();
    for (let i = 0; i < event.changedTouches.length; i++) {
        const changedTouch = event.changedTouches[i];
        const ongoingTouch = touches.get(changedTouch.identifier);
        if (ongoingTouch) {
            ongoingTouch.pageX = changedTouch.pageX;
            ongoingTouch.pageY = changedTouch.pageY;
        }
    }

    if (touches.size === 1) {
        const offsetX = event.target.getBoundingClientRect().left;
        const offsetY = event.target.getBoundingClientRect().top;

        const touch0 = touches.get(params.touchStartId);
        if (!touch0) {
            return;
        }
        let x = (touch0.pageX - touch0.startX) / 200;
        let y = -(touch0.pageY - touch0.startY) / 200;

        let ascaled = mul(params.touchStartAScale, [x,y]);
        let bscaled = mul(params.touchStartBScale, [x,y]);
        if (params.drag === "zoom") {
            params.a = sub(params.touchStartA, ascaled);
            params.b = sub(params.touchStartB, bscaled);
        } else if (params.drag === "distort") {
            params.a[1] = params.touchStartA[1] - ascaled[1];
            params.b[1] = params.touchStartB[1] - bscaled[1];
        }

        // params.ascale[1] = params.touchStartAScale[1] - ascaled[1];
        // params.bscale[1] = params.touchStartBScale[1] - bscaled[1];

        repaint();
    }
    
    if (touches.size === 2) {
        const touch0 = touches.get(params.touchStartId);
        const touch1 = Array.from(touches.values()).find(t => t.identifier !== params.touchStartId);
        if (!touch0 || !touch1) {
            return;
        }

        let x0 = (touch0.pageX - touch0.startX) / 200;
        let y0 = -(touch0.pageY - touch0.startY) / 200;

        let x1 = (touch1.pageX - touch1.startX) / 200;
        let y1 = -(touch1.pageY - touch1.startY) / 200;

        let startd = [
            touch1.startX - touch0.startX,
            -(touch1.startY - touch0.startY)
        ];
        let endd = [
            touch1.pageX - touch0.pageX,
            -(touch1.pageY - touch0.pageY)
        ];
        let rotate = div(startd, endd);

        let ascaled = mul(params.touchStartAScale, [x0,y0]);
        let bscaled = mul(params.touchStartBScale, [x0,y0]);
        if (params.drag === "zoom") {
            params.a = sub(params.touchStartA, ascaled);
            params.b = sub(params.touchStartB, bscaled);
            params.ascale = mul(params.touchStartAScale, rotate);
            params.bscale = mul(params.touchStartBScale, rotate);
        }
        repaint();
    }
}

function repaint() {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    paint();
}

function scale_rotate(scaleX, scaleY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.mandelbrot) {
        if (params.drag === "ca") {
            let c0 = -params.ascale[0] - params.bscale[0];
            let c1 = -params.ascale[1] - params.bscale[1];
            let cincrx = c0 * scaleX - c1 * scaleY - c0;
            let cincry = c0 * scaleY + c1 * scaleX - c1;
            params.ascale[0] -= cincrx;
            params.ascale[1] -= cincry;
        }
        if (params.drag === "bc") {
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
        if (params.drag === "ab") {
            let aincrx = params.ascale[0] * scaleX - params.ascale[1] * scaleY - params.ascale[0];
            let aincry = params.ascale[0] * scaleY + params.ascale[1] * scaleX - params.ascale[1];
            params.ascale[0] += aincrx;
            params.ascale[1] += aincry;
            params.bscale[0] -= aincrx;
            params.bscale[1] -= aincry;
        }
        if (params.drag === "all") {
            params.ascale = [
                params.ascale[0] * scaleX - params.ascale[1] * scaleY,
                params.ascale[0] * scaleY + params.ascale[1] * scaleX
            ];
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
    } else {
        params.z0Scale /= scale;
    }
}

function move(deltaX, deltaY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.drag === "ca") {
        const cscale = [
            (scale[0] + params.bscale[0]),
            (params.ascale[1] + params.bscale[1])
        ];
        params.a[0] += deltaX * cscale[0] - deltaY * cscale[1];
        params.a[1] += deltaY * cscale[0] + deltaX * cscale[1];
    }
    if (params.drag === "bc") {
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
    if (params.drag === "ab") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] -= deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.b[1] -= deltaY * params.ascale[0] + deltaX * params.ascale[1];
    }
    if (params.drag === "all") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
}

function update_buttons() {
    document.getElementById("button_distort").classList.remove("active");
    document.getElementById("button_zoom").classList.remove("active");
    if (params.drag === "distort") {
        document.getElementById("button_distort").classList.add("active");
    } else if (params.drag === "zoom") {
        document.getElementById("button_zoom").classList.add("active");
    }
}


function csqrt(z) {
    const r = Math.sqrt(cnorm(z));
    const theta = Math.atan2(z[1], z[0]);
    return [
        r * Math.cos(theta / 2.0),
        r * Math.sin(theta / 2.0)
    ];
}

function solve_quadratic(a, b, c) {
    const discriminant = csqrt(sub(mul(b, b), scale(4.0, mul(a, c))));
    const root1 = div(sub(discriminant, b), scale(2.0, a));
    return root1;
}

class Derivatives {
    constructor(value, dz, dzz, dp, dpz, dq, dqz) {
        this.value = value;
        this.dz = dz;
        this.dzz = dzz;
        this.dp = dp;
        this.dpz = dpz;
        this.dq = dq;
        this.dqz = dqz;
    }

    static fromConstant(value) {
        const z = [0.0, 0.0];
        return new Derivatives(value, z, z, z, z, z, z, z, z);
    }

    static fromRealConstant(value) {
        return Derivatives.fromConstant([value, 0.0]);
    }

    static fromZ(z) {
        const one = [1.0, 0.0];
        const zero = [0.0, 0.0];
        return new Derivatives(z, one, zero, zero, zero, zero, zero);
    }

    static fromP(p) {
        const one = [1.0, 0.0];
        const zero = [0.0, 0.0];
        return new Derivatives(p, zero, zero, one, zero, zero, zero);
    }

    static fromQ(q) {
        const one = [1.0, 0.0];
        const zero = [0.0, 0.0];
        return new Derivatives(q, zero, zero, zero, zero, one, zero);
    }

    add(other) {
        return new Derivatives(
            add(this.value, other.value),
            add(this.dz, other.dz),
            add(this.dzz, other.dzz),
            add(this.dp, other.dp),
            add(this.dpz, other.dpz),
            add(this.dq, other.dq),
            add(this.dqz, other.dqz)
        );
    }

    sub(other) {
        return new Derivatives(
            sub(this.value, other.value),
            sub(this.dz, other.dz),
            sub(this.dzz, other.dzz),
            sub(this.dp, other.dp),
            sub(this.dpz, other.dpz),
            sub(this.dq, other.dq),
            sub(this.dqz, other.dqz)
        );
    }

    scale(r) {
        return new Derivatives(
            scale(r, this.value),
            scale(r, this.dz),
            scale(r, this.dzz),
            scale(r, this.dp),
            scale(r, this.dpz),
            scale(r, this.dq),
            scale(r, this.dqz)
        );
    }

    mul(other) {
        return new Derivatives(
            mul(this.value, other.value),
            add(
                mul(this.dz, other.value),
                mul(this.value, other.dz)
            ),
            add3(
                mul(this.dzz, other.value),
                scale(2.0, mul(this.dz, other.dz)),
                mul(this.value, other.dzz)
            ),
            add(
                mul(this.dp, other.value),
                mul(this.value, other.dp)
            ),
            add4(
                mul(this.dpz, other.value),
                mul(this.dp, other.dz),
                mul(this.dz, other.dp),
                mul(this.value, other.dpz)
            ),
            add(
                mul(this.dq, other.value),
                mul(this.value, other.dq)
            ),
            add4(
                mul(this.dqz, other.value),
                mul(this.dq, other.dz),
                mul(this.dz, other.dq),
                mul(this.value, other.dqz)
            )
        );
    }

    recip() {
        const f = div([1.0, 0.0], this.value);
        const f1 = scale(-1, mul(f, f));
        const f2 = scale(-2, mul(mul(f, f), f));
        return new Derivatives(
            f,
            mul(f1, this.dz),
            add(
                mul(f2, mul(this.dz, this.dz)),
                mul(f1, this.dzz)
            ),
            mul(f1, this.dp),
            add(
                mul(f2, mul(this.dz, this.dp)),
                mul(f1, this.dpz)
            ),
            mul(f1, this.dq),
            add(
                mul(f2, mul(this.dz, this.dq)),
                mul(f1, this.dqz)
            )
        );
    }

    square() {
        return this.mul(this);
    }

    div(other) {
        return this.mul(other.recip());
    }
}

function target(x, y) {
    const maxiter = 1000;
    const maxper = 10;
    const bailin = 0.0005;
    let pixel = [x,y];
    let a = add(params.a, mul(params.ascale, pixel));
    let b = add(params.b, mul(params.bscale, pixel));
    let a1 = sub(a, [1.0, 0.0]);
    let b1 = sub(b, [1.0, 0.0]);
    let z = solve_quadratic(
        mul(a, a1),
        scale(2.0, mul(a, b)),
        mul(b, b1)
    );
    let orbitStart = null;
    let period = null;
    for (let i = 0 ; i < maxiter; i++) {
        const z2 = mul(z, z);
        z = div(
            add(mul(a, z2), mul(b1, z)),
            add(mul(a1, z), b)
        );
        if (i === maxiter - maxper) {
            orbitStart = z;
        }
        if (i > maxiter - maxper) {
            const d = cnorm(sub(z, orbitStart));
            if (d < bailin) {
                period = i - (maxiter - maxper);
                break;
            }
        }
    }
    console.log("Targeted period:", period);
    // console.log("Targeted point:", z);
    if (period === null) {
        return;
    }

    let Z = Derivatives.fromZ(z);
    const A = Derivatives.fromP(a);
    const B = Derivatives.fromQ(b);
    const A1 = A.sub(Derivatives.fromRealConstant(1.0));
    const B1 = B.sub(Derivatives.fromRealConstant(1.0));
    for (let i = 0; i < period; i++) {
        const Z2 = Z.square();
        const numerator = A.mul(Z2).add(B1.mul(Z));
        const denominator = A1.mul(Z).add(B);
        Z = numerator.div(denominator);
    }
    console.log(Z);

    const rootDirP = div(Z.dp, sub([1.0, 0.0], Z.dz));
    const rootDirQ = div(Z.dq, sub([1.0, 0.0], Z.dz));
    // console.log("Root direction P:", rootDirP);
    // console.log("Root direction Q:", rootDirQ);

    // Let's test it out!
    // const epsilon = [0.000, 0.0001];
    // const a_ = a;
    // const b_ = add(b, epsilon);
    // let z_ = add(z, mul(rootDirQ, epsilon));
    // let a1_ = sub(a_, [1.0, 0.0]);
    // let b1_ = sub(b_, [1.0, 0.0]);
    // console.log("Starting z_", z_);
    // for (let i = 0; i < period; i++) {
    //     const z2_ = mul(z_, z_);
    //     z_ = div(
    //         add(mul(a_, z2_), mul(b1_, z_)),
    //         add(mul(a1_, z_), b_)
    //     );
    // }
    // console.log("Ending z_ ", z_);

    // console.log("d/dz", Z.dz);

    const rootTrackP = add(mul(Z.dzz, rootDirP), Z.dpz);
    const rootTrackQ = add(mul(Z.dzz, rootDirQ), Z.dqz);
    console.log("Root track P:", rootTrackP);
    console.log("Arg:", Math.atan2(rootTrackP[1], rootTrackP[0]) * 180.0 / Math.PI, "Abs:", cnorm(rootTrackP));
    // console.log("Root track Q:", rootTrackQ);
    const rootTrackPixel = add(mul(rootTrackP, params.ascale), mul(rootTrackQ, params.bscale));
    console.log("Root track pixel:", rootTrackPixel);

    params.plot_points = [
        add(pixel, div([3.0,0.0], rootTrackPixel))
    ];
    repaint();

    // const dirP = rootTrackP;
    // const dirQ = rootTrackQ;
    // const sf = 0.1 / Math.hypot(cnorm(dirP), cnorm(dirQ), cnorm(add(dirP, dirQ)));
    // params.a = add(a, scale(sf, dirP));
    // params.b = add(b, scale(sf, dirQ));
    // params.ascale = scale(sf, dirP);
    // params.bscale = scale(sf, dirQ);
    // repaint();
}

function start() {
    glStuff = setup();
    update_buttons();
    paint();
}

window.onload = start;
    </script>
    <style>
button {
    padding: 10px;
}
button.active {
    background: #ffaaaa;
}
    </style>
</head>
<body>
    <button id="button_zoom" onclick="params.drag='zoom'; update_buttons()">Zoom</button>
    <button id="button_distort" onclick="params.drag='distort'; update_buttons()">Distort</button>
    <br>
    <canvas id="canvas" width="400" height="800" onmousedown="mousedown()" onmousemove="mousemove()" onwheel="mousewheel()" ontouchstart="touchstart()" ontouchmove="touchmove()" ontouchend="touchend()"></canvas>
</body>
</html>