<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

let params = {
    a: [-0.0, 0.1],
    ascale: [0.1, 0.0],
    b: [0.2, -0.4],
    bscale: [0.1, 0.0],
    z0: [0.0, 0.0],
    z0Scale: [2.0, 0.0],
    julia: false,
    flip: false,
    drag: "zoom",
    drag_start: [0.0, 0.0],
    timer: null,
    last_moved: 0,
    high_count: 0,
    julia_distort_start_a: [0.0, 0.0],
    julia_distort_start_b: [0.0, 0.0],
    touch0id: null,
    touch1id: null,
};
let glStuff = null;
let touches = new Map();

function fragmentShaderSource(max_iter, max_period) {
    return `
        precision highp float;
        varying vec2 a;
        varying vec2 b;
        varying vec2 z0;
        uniform bool uMandelbrot;
        uniform float uBailout;
        uniform float uBailin;
        uniform bool uFlip;

        const vec2 two = vec2(2.0, 0.0);
        const vec2 one = vec2(1.0, 0.0);

        vec2 csqrt(vec2 z) {
            float r = length(z);
            float theta = atan(z.y, z.x);
            return vec2(
                sqrt(r) * cos(theta / 2.0),
                sqrt(r) * sin(theta / 2.0)
            );
        }

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        vec4 solve_quadratic(vec2 a, vec2 b, vec2 c) {
            vec2 discriminant = csqrt(mul(b, b) - 4.0 * mul(a, c));
            vec2 root1 = div(-b + discriminant, 2.0 * a);
            vec2 root2 = div(-b - discriminant, 2.0 * a);
            return vec4(root1, root2);  // return both roots packed together
        }

        vec4 mandelbrot(vec2 A, vec2 B, vec2 actual_z0) {
            vec2 z = actual_z0;
            const int max_iteration = ${max_iter};
            int iter = 0;
            vec2 prevZ = z;
            int brightness = 0;
            int period = -1;
            for (int iteration = 0; iteration < max_iteration; iteration++) {
                vec2 z2 = mul(z, z);
                z = div(
                    mul(A, z2) + mul(B - one, z),
                    mul(A - one, z) + B
                );
                if (length(z) > uBailout) {
                    period = 0;
                    brightness = iteration;
                    break;
                }

                float d = length(z - prevZ);
                if (d < uBailin && brightness == 0) {
                    brightness = iteration;
                }
                if (mod(float(iteration), 32.0) < 0.001 || iteration == ${max_iter - max_period}) {
                    prevZ = z;
                }
                if (iteration > ${max_iter - max_period}) {
                    if (d < uBailin) {
                        period = iteration - ${max_iter - max_period + 1};
                        break;
                    }
                }
            }
            // float brightnessf = 0.25 + sin(sqrt(max(float(brightness), 32.0) * 0.1)) * 0.25;
            // float brightnessf = 0.1 + log(float(brightness) + 10.0) * 0.1;
            float brightnessf = -0.6 + sqrt(max(float(brightness), 32.0) + 10.0) * 0.1;
            float theta = float(period) * 3.88;
            if (period == -1) {
                return vec4(5.0 * brightnessf, 5.0 * brightnessf, 5.0 * brightnessf, 1.0);
            }
            vec3 color = vec3(1.0 + cos(theta), 1.0 + cos(theta + 2.1), 1.0 + cos(theta + 4.2)) * brightnessf;
            return vec4(color, 1.0);
        }

        void main(void) {
            vec2 q = (a + b) * 0.5;
            vec2 A = div(mul(q, (q - one)), mul(a - q, a - q));
            vec2 B = mul(one - A, q);
            if (uMandelbrot) {
                gl_FragColor = mandelbrot(A, B, uFlip ? b : a);
            } else {
                gl_FragColor = mandelbrot(A, B, z0);
            }
        }
    `;
}
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.9, 0.9, 1.0);

    // Mandelbrot vertex shader program
    const vsSource = `
        precision highp float;
        attribute vec2 aVertexPosition;
        uniform vec2 uz0;
        uniform vec2 uz0Scale;
        uniform vec2 ua;
        uniform vec2 ub;
        uniform vec2 uascale;
        uniform vec2 ubscale;
        uniform vec2 uNudge;
        varying vec2 a;
        varying vec2 b;
        varying vec2 z0;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vec2 vp = aVertexPosition * vec2(1.0, 2.0) + uNudge;
            a = ua + mul(vp, uascale);
            b = ub + mul(vp, ubscale);
            z0 = uz0 + mul(vp, uz0Scale);
        }
    `;

    // Mandelbrot/Julia fragment shader program
    const fsSource = fragmentShaderSource(200, 32);
    const fsSourceHigh = fragmentShaderSource(2000, 100);

    // Initialize shaders
    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);

    // Initialize shaders (high iteration count)
    const fragmentShaderHigh = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderHigh, fsSourceHigh);
    ctx.compileShader(fragmentShaderHigh);
    if (!ctx.getShaderParameter(fragmentShaderHigh, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the high iteration shader: " +
            ctx.getShaderInfoLog(fragmentShaderHigh));
        return null;
    }
    const shaderProgramHigh = ctx.createProgram();
    ctx.attachShader(shaderProgramHigh, vertexShader);
    ctx.attachShader(shaderProgramHigh, fragmentShaderHigh);
    ctx.linkProgram(shaderProgramHigh);

    // Shaders for texture blitting
    const vsSourceBlit = `
        attribute vec2 aVertexPosition;
        varying vec2 vTexCoord;
        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vTexCoord = (aVertexPosition + vec2(1.0, 1.0)) * 0.5;
        }
    `;
    const fsSourceBlit = `
        precision highp float;
        varying vec2 vTexCoord;
        uniform sampler2D uTexture;
        void main(void) {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;
    const vertexShaderBlit = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderBlit, vsSourceBlit);
    ctx.compileShader(vertexShaderBlit);
    const fragmentShaderBlit = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderBlit, fsSourceBlit);
    ctx.compileShader(fragmentShaderBlit);
    if (!ctx.getShaderParameter(vertexShaderBlit, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderBlit, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the blit shaders: " +
            ctx.getShaderInfoLog(vertexShaderBlit) + " " +
            ctx.getShaderInfoLog(fragmentShaderBlit));
        return null;
    }
    const shaderProgramBlit = ctx.createProgram();
    ctx.attachShader(shaderProgramBlit, vertexShaderBlit);
    ctx.attachShader(shaderProgramBlit, fragmentShaderBlit);
    ctx.linkProgram(shaderProgramBlit);

    // Shaders for point markers
    const vsSourcePoint = `
        precision highp float;
        uniform vec2 uVertexPosition;
        uniform float uPointSize;
        void main(void) {
            gl_Position = vec4(uVertexPosition * vec2(1.0, 0.5), 0.0, 1.0);
            gl_PointSize = uPointSize;
        }
    `;
    const fsSourcePoint = `
        precision highp float;
        uniform vec3 uColor;
        void main(void) {
            gl_FragColor = vec4(uColor, 1.0);
        }
    `;
    const vertexShaderPoint = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderPoint, vsSourcePoint);
    ctx.compileShader(vertexShaderPoint);
    const fragmentShaderPoint = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderPoint, fsSourcePoint);
    ctx.compileShader(fragmentShaderPoint);
    if (!ctx.getShaderParameter(vertexShaderPoint, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderPoint, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the point shaders: " +
            ctx.getShaderInfoLog(vertexShaderPoint) + " " +
            ctx.getShaderInfoLog(fragmentShaderPoint));
        return null;
    }
    const shaderProgramPoint = ctx.createProgram();
    ctx.attachShader(shaderProgramPoint, vertexShaderPoint);
    ctx.attachShader(shaderProgramPoint, fragmentShaderPoint);
    ctx.linkProgram(shaderProgramPoint);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    // Create texture to hold low-iteration Mandelbrot image
    const fbWidth = 400;
    const fbHeight = 800;
    const destTexture = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTexture);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidth, fbHeight, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render low-iteration Mandelbrot image into
    const framebuffer = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffer);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTexture, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    // Create texture to hold high-iteration Mandelbrot image
    const fbWidthHigh = 400;
    const fbHeightHigh = 800;
    const destTextureHigh = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTextureHigh);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidthHigh, fbHeightHigh, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render high-iteration Mandelbrot image into
    const framebufferHigh = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebufferHigh);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTextureHigh, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    return {
        main: {
            shaderProgram,
            aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgram, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgram, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgram, "uz0Scale"),
            ua: ctx.getUniformLocation(shaderProgram, "ua"),
            ub: ctx.getUniformLocation(shaderProgram, "ub"),
            uascale: ctx.getUniformLocation(shaderProgram, "uascale"),
            ubscale: ctx.getUniformLocation(shaderProgram, "ubscale"),
            uBailout: ctx.getUniformLocation(shaderProgram, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgram, "uBailin"),
            bailin: 0.002,
            bailout: 1000,
            uNudge: ctx.getUniformLocation(shaderProgram, "uNudge"),
            vertexBuffer,
            destTexture,
            framebuffer,
            fbWidth,
            fbHeight,
            uFlip: ctx.getUniformLocation(shaderProgram, "uFlip"),
        },
        high: {
            shaderProgram: shaderProgramHigh,
            aVertexPosition: ctx.getAttribLocation(shaderProgramHigh, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgramHigh, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgramHigh, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgramHigh, "uz0Scale"),
            ua: ctx.getUniformLocation(shaderProgramHigh, "ua"),
            ub: ctx.getUniformLocation(shaderProgramHigh, "ub"),
            uascale: ctx.getUniformLocation(shaderProgramHigh, "uascale"),
            ubscale: ctx.getUniformLocation(shaderProgramHigh, "ubscale"),
            uBailout: ctx.getUniformLocation(shaderProgramHigh, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgramHigh, "uBailin"),
            bailin: 0.001,
            bailout: 1000,
            uNudge: ctx.getUniformLocation(shaderProgramHigh, "uNudge"),
            vertexBuffer,
            destTexture: destTextureHigh,
            framebuffer: framebufferHigh,
            fbWidth: fbWidthHigh,
            fbHeight: fbHeightHigh,
            uFlip: ctx.getUniformLocation(shaderProgramHigh, "uFlip"),
        },
        blit: {
            shaderProgram: shaderProgramBlit,
            aVertexPosition: ctx.getAttribLocation(shaderProgramBlit, "aVertexPosition"),
            uTexture: ctx.getUniformLocation(shaderProgramBlit, "uTexture"),
            vertexBuffer,
        },
        point: {
            shaderProgram: shaderProgramPoint,
            uVertexPosition: ctx.getUniformLocation(shaderProgramPoint, "uVertexPosition"),
            uPointSize: ctx.getUniformLocation(shaderProgramPoint, "uPointSize"),
            uColor: ctx.getUniformLocation(shaderProgramPoint, "uColor"),
        }
    };
}

function paintMandelbrot(ctx, stuff, nudgeX, nudgeY) {
    // Draw the Julia or Mandelbrot set
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform1f(stuff.uBailout, stuff.bailout);
    ctx.uniform1f(stuff.uBailin, stuff.bailin);
    ctx.uniform2f(stuff.uNudge, nudgeX, nudgeY);
    ctx.uniform1i(stuff.uFlip, params.flip);
    if (params.julia) {
        ctx.uniform1i(stuff.uMandelbrot, false);
        ctx.uniform2f(stuff.uz0Scale, params.z0Scale[0], params.z0Scale[1]);
        ctx.uniform2f(stuff.ua, params.a[0], params.a[1]);
        ctx.uniform2f(stuff.ub, params.b[0], params.b[1]);
        ctx.uniform2f(stuff.uascale, 0.0, 0.0);
        ctx.uniform2f(stuff.ubscale, 0.0, 0.0);
        ctx.uniform2f(stuff.uz0, params.z0[0], params.z0[1]);
        ctx.uniform1f(stuff.uBrightness, stuff.brightness);
    } else {
        ctx.uniform1i(stuff.uMandelbrot, true);
        ctx.uniform1f(stuff.uz0Scale, 0.0);
        ctx.uniform2f(stuff.ua, params.a[0], params.a[1]);
        ctx.uniform2f(stuff.uascale, params.ascale[0], params.ascale[1]);
        ctx.uniform2f(stuff.ub, params.b[0], params.b[1]);
        ctx.uniform2f(stuff.ubscale, params.bscale[0], params.bscale[1]);
        ctx.uniform1f(stuff.uBrightness, stuff.brightness);
    }
    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
}

function blit_texture(ctx, stuff, texture) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.activeTexture(ctx.TEXTURE0);
    ctx.bindTexture(ctx.TEXTURE_2D, texture);
    ctx.uniform1i(stuff.uTexture, 0);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);

    ctx.bindTexture(ctx.TEXTURE_2D, null);
}

function draw_point(ctx, stuff, x, y, r, g, b) {
    const xy = div(sub([x, y], params.z0), params.z0Scale);

    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform2f(stuff.uVertexPosition, xy[0], xy[1]);
    ctx.uniform1f(stuff.uPointSize, 10.0);
    ctx.uniform3f(stuff.uColor, r, g, b);

    ctx.drawArrays(ctx.POINTS, 0, 1);
}

function paint() {
    const ctx = document.getElementById("canvas").getContext("webgl");
    if (params.high_count === 0) {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.main.framebuffer);
        ctx.viewport(0, 0, glStuff.main.fbWidth, glStuff.main.fbHeight);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        paintMandelbrot(ctx, glStuff.main, 0, 0);

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        blit_texture(ctx, glStuff.blit, glStuff.main.destTexture);

        if (params.julia) {
            draw_point(ctx, glStuff.point, params.a[0], params.a[1], 0.0, 0.0, 1.0);
            draw_point(ctx, glStuff.point, params.b[0], params.b[1], 0.0, 0.0, 1.0);
            draw_point(ctx, glStuff.point, 0.0, 0.0, 0.0, 0.75, 0.75);
            draw_point(ctx, glStuff.point, 1.0, 0.0, 0.0, 0.75, 0.75);
        }

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        params.high_count += 1;
        params.timer = setTimeout(paint, 300);
    } else {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.high.framebuffer);
        ctx.viewport(0, 0, glStuff.high.fbWidth, glStuff.high.fbHeight);

        if (params.high_count === 1) {
            ctx.clear(ctx.COLOR_BUFFER_BIT);
            paintMandelbrot(ctx, glStuff.high, 0, 0);
        } else {
            ctx.enable(ctx.BLEND);
            ctx.blendEquation(ctx.FUNC_ADD);
            ctx.blendFuncSeparate(ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA, ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA);
            ctx.blendColor(1.0, 1.0, 1.0, 1.0 / params.high_count);
            let nudgeX = (Math.random() - 0.5) * 0.5 / 100;
            let nudgeY = (Math.random() - 0.5) * 0.5 / 100;
            paintMandelbrot(ctx, glStuff.high, nudgeX, nudgeY);
            ctx.disable(ctx.BLEND);
        }

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        blit_texture(ctx, glStuff.blit, glStuff.high.destTexture);
        params.high_count += 1;

        if (params.julia) {
            draw_point(ctx, glStuff.point, params.a[0], params.a[1], 0.0, 0.0, 1.0);
            draw_point(ctx, glStuff.point, params.b[0], params.b[1], 0.0, 0.0, 1.0);
            draw_point(ctx, glStuff.point, 0.0, 0.0, 0.0, 0.75, 0.75);
            draw_point(ctx, glStuff.point, 1.0, 0.0, 0.0, 0.75, 0.75);
        }

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        if (params.high_count < 8) {
            params.timer = setTimeout(paint, 100);
        }
    }
}

function update_buttons() {
    document.getElementById("button_distort").classList.remove("active");
    document.getElementById("button_zoom").classList.remove("active");
    document.getElementById("button_flip").classList.remove("active");
    document.getElementById("button_julia").classList.remove("active");
    document.getElementById("button_flip").classList.remove("disabled");
    if (params.julia) {
        document.getElementById("button_julia").classList.add("active");
        document.getElementById("button_flip").classList.add("disabled");
    } else {
        if (params.flip) {
            document.getElementById("button_flip").classList.add("active");
        }
    }
    if (params.drag === "distort") {
        document.getElementById("button_distort").classList.add("active");
    } else if (params.drag === "zoom") {
        document.getElementById("button_zoom").classList.add("active");
    }
}

function mousedown() {
    const x = event.clientX;
    const y = event.clientY;
    params.drag_start = [x, y];
    // update_point(x,y, false, params.last_alternate);
    event.preventDefault();
}

function mousemove() {
    const x = event.clientX;
    const y = event.clientY;
    if (event.buttons === 1) {
        move(
            -(x - params.drag_start[0]) * 0.005,
            (y - params.drag_start[1]) * 0.005
        );
        paint();
    }
    params.drag_start = [x, y];
    event.preventDefault();
}

function mousewheel() {
    const delta = event.deltaY;
    const scale = Math.exp(delta * 0.001);
    scale_rotate(scale, 0);
    paint();
    event.preventDefault();
}

function touchstart() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];
    const touch = {
        startX: changedTouch.pageX,
        startY: changedTouch.pageY,
        pageX: changedTouch.pageX,
        pageY: changedTouch.pageY,
    };
    touches.set(changedTouch.identifier, touch);

    if (touches.size === 1 && params.julia) {
        params.touch0id = changedTouch.identifier;
    }
    if (touches.size === 2 && params.julia) {
        params.touch1id = changedTouch.identifier;
        params.julia_distort_start_a = [params.a[0], params.a[1]];
        params.julia_distort_start_b = [params.b[0], params.b[1]];
    }
}

function touchend() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];
    const ongoingTouch = touches.get(changedTouch.identifier);
    touches.delete(changedTouch.identifier);
}

function add(x, y) {
    return [
        x[0] + y[0],
        x[1] + y[1]
    ];
}

function sub(x, y) {
    return [
        x[0] - y[0],
        x[1] - y[1]
    ];
}

function mul(x, y) {
    return [
        x[0] * y[0] - x[1] * y[1],
        x[0] * y[1] + x[1] * y[0]
    ];
}

function div(x, y) {
    const denom = y[0] * y[0] + y[1] * y[1];
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function scale(r, c) {
    return [
        r * c[0],
        r * c[1]
    ];
}

function cnorm(c) {
    return Math.hypot(c[0], c[1]);
}

function dot(x, y) {
    return x[0] * y[0] + x[1] * y[1];
}

function distort_julia() {
    if (touches.size !== 2) {
        return;
    }
    for (let i = 0; i < event.changedTouches.length; i++) {
        const touch = event.changedTouches[i];
        const ongoingTouch = touches.get(touch.identifier);
        if (!ongoingTouch) {
            return;
        }
        ongoingTouch.delta = [(touch.pageX - ongoingTouch.pageX) / 50, -(touch.pageY - ongoingTouch.pageY) / 50];
        ongoingTouch.pageX = touch.pageX;
        ongoingTouch.pageY = touch.pageY;
    }

    const touch0 = touches.get(params.touch0id);
    const touch1 = touches.get(params.touch1id);

    // const drag = scale(0.5, add(touch0.delta, touch1.delta));
    // const orientation = sub([touch1.pageX, touch1.pageY], [touch0.pageX, touch0.pageY]);
    // const orthog = [-orientation[1], orientation[0]];
    // const expand = -0.003 * dot(sub(touch1.delta, touch0.delta), orientation);
    // const rotate = 0.003 * dot(sub(touch1.delta, touch0.delta), orthog);

    // const direction = sub(params.a, params.b);
    // const orthogDirection = [-direction[1], direction[0]];
    // const a_delta = add(drag, add(scale(expand, direction), scale(-rotate, orthogDirection)));
    // const b_delta = add(drag, add(scale(-expand, direction), scale(rotate, orthogDirection)));

    // params.a = add(params.a, div(a_delta, params.z0Scale));
    // params.b = add(params.b, div(b_delta, params.z0Scale));

    const offsetX = event.target.getBoundingClientRect().left;
    const offsetY = event.target.getBoundingClientRect().top;

    
    const origA = add(params.z0, mul([(touch0.startX - offsetX) / 200 - 1, -(touch0.startY - offsetY) / 200 + 2], params.z0Scale));
    const origB = add(params.z0, mul([(touch1.startX - offsetX) / 200 - 1, -(touch1.startY - offsetY) / 200 + 2], params.z0Scale));
    const pressA = add(params.z0, mul([(touch0.pageX - offsetX) / 200 - 1, -(touch0.pageY - offsetY) / 200 + 2], params.z0Scale));
    const pressB = add(params.z0, mul([(touch1.pageX - offsetX) / 200 - 1, -(touch1.pageY - offsetY) / 200 + 2], params.z0Scale));
    
    const shiftA = sub(
        add(params.julia_distort_start_a,
        div(
            mul(
                sub(pressA, origA),
                sub(params.julia_distort_start_b, params.julia_distort_start_a),
            ),
            sub(origB, origA)
        )
    ), params.a);
    
    const shiftB = sub(
        params.b = add(params.julia_distort_start_b,
        div(
            mul(
                sub(pressB, origB),
                sub(params.julia_distort_start_b, params.julia_distort_start_a),
            ),
            sub(origB, origA)
        )
    ), params.b);
    const drag = scale(0.5, add(sub(pressA, origA), sub(pressB, origB)));
    const wrongDrag = scale(0.5, sub(shiftA, shiftB));
    const alter = sub(drag, wrongDrag);
    
    params.a = add(params.a, add(shiftA, alter));
    params.b = add(params.b, add(shiftB, alter));

    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    paint();
}

function doubletouch() {
    const touch1 = event.changedTouches[0];
    const touch2 = event.changedTouches[1];
    const prevTouch1 = touches.get(touch1.identifier);
    const prevTouch2 = touches.get(touch2.identifier);
    const prevDist = Math.hypot(
        prevTouch2.pageX - prevTouch1.pageX,
        prevTouch2.pageY - prevTouch1.pageY);
    const newDist = Math.hypot(
        touch2.pageX - touch1.pageX,
        touch2.pageY - touch1.pageY);
    const prevAngle = Math.atan2(
        prevTouch2.pageY - prevTouch1.pageY,
        prevTouch2.pageX - prevTouch1.pageX);
    const newAngle = Math.atan2(
        touch2.pageY - touch1.pageY,
        touch2.pageX - touch1.pageX);
    const angleDelta = newAngle - prevAngle;
    const scaleX = Math.cos(angleDelta) * prevDist / newDist;
    const scaleY = Math.sin(angleDelta) * prevDist / newDist;
    scale_rotate(scaleX, scaleY);

    const deltaX = -((touch1.pageX + touch2.pageX) / 2 - (prevTouch1.pageX + prevTouch2.pageX) / 2) * 0.005;
    const deltaY = ((touch1.pageY + touch2.pageY) / 2 - (prevTouch1.pageY + prevTouch2.pageY) / 2) * 0.005;
    move(deltaX, deltaY);

    prevTouch1.pageX = touch1.pageX;
    prevTouch1.pageY = touch1.pageY;
    prevTouch2.pageX = touch2.pageX;
    prevTouch2.pageY = touch2.pageY;
    paint();
}

function touchmove() {
    event.preventDefault();
    if (params.julia && params.drag === "distort") {
        distort_julia();
        return;
    }
    if (event.changedTouches.length === 2) {
        doubletouch();
        return;
    }
    if (event.changedTouches.length !== 1) {
        return;
    }
    const changedTouch = event.changedTouches[0];
    const ongoingTouch = touches.get(changedTouch.identifier);
    if (!ongoingTouch) {
        return;
    }
    const deltaX = -(changedTouch.pageX - ongoingTouch.pageX) * 0.005;
    const deltaY = (changedTouch.pageY - ongoingTouch.pageY) * 0.005;
    ongoingTouch.pageX = changedTouch.pageX;
    ongoingTouch.pageY = changedTouch.pageY;
    move(deltaX, deltaY);
    paint();
}

function scale_rotate(scaleX, scaleY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.julia) {
        // if (params.drag === "distort") {
        //     const middle = [params.a[0] * 0.5 + params.b[0] * 0.5,
        //                     params.a[1] * 0.5 + params.b[1] * 0.5];
        //     const dif = [
        //         params.a[0] - middle[0],
        //         params.a[1] - middle[1]
        //     ];
        //     params.a = [
        //         middle[0] + (dif[0] * scaleX - dif[1] * scaleY),
        //         middle[1] + (dif[0] * scaleY + dif[1] * scaleX)
        //     ];
        //     params.b = [
        //         middle[0] - (dif[0] * scaleX - dif[1] * scaleY),
        //         middle[1] - (dif[0] * scaleY + dif[1] * scaleX)
        //     ];
        // }
        if (params.drag === "zoom") {
            params.z0Scale = [
                params.z0Scale[0] * scaleX - params.z0Scale[1] * scaleY,
                params.z0Scale[0] * scaleY + params.z0Scale[1] * scaleX
            ];
        }
    } else {
        if (params.drag === "distort") {
            const a_hyp = 1.0 / Math.hypot(params.ascale[0], params.ascale[1]);
            const b_hyp = 1.0 / Math.hypot(params.bscale[0], params.bscale[1]);
            const a_amount = (0.9 * a_hyp + 0.1 * b_hyp) / (a_hyp + b_hyp);
            const b_amount = (0.9 * b_hyp + 0.1 * a_hyp) / (a_hyp + b_hyp);
            const a_diff = [
                params.ascale[0] * scaleX - params.ascale[1] * scaleY - params.ascale[0],
                params.ascale[0] * scaleY + params.ascale[1] * scaleX - params.ascale[1]
            ];
            const b_diff = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY - params.bscale[0],
                params.bscale[0] * scaleY + params.bscale[1] * scaleX - params.bscale[1]
            ]
            params.ascale = [
                params.ascale[0] + a_diff[0] * a_amount,
                params.ascale[1] + a_diff[1] * a_amount
            ];
            params.bscale = [
                params.bscale[0] - b_diff[0] * b_amount,
                params.bscale[1] - b_diff[1] * b_amount
            ];
        }
        if (params.drag === "zoom") {
            params.ascale = [
                params.ascale[0] * scaleX - params.ascale[1] * scaleY,
                params.ascale[0] * scaleY + params.ascale[1] * scaleX
            ];
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
    }
}

function move(deltaX, deltaY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.drag === "distort" && !params.julia) {
        const a_hyp = 1.0 / Math.hypot(params.ascale[0], params.ascale[1]);
        const b_hyp = 1.0 / Math.hypot(params.bscale[0], params.bscale[1]);
        const a_amount = a_hyp / (a_hyp + b_hyp);
        const b_amount = b_hyp / (a_hyp + b_hyp);
        params.a[0] += (deltaX * params.ascale[0] - deltaY * params.ascale[1]) * a_amount;
        params.a[1] += (deltaY * params.ascale[0] + deltaX * params.ascale[1]) * a_amount;
        params.b[0] -= (deltaX * params.bscale[0] - deltaY * params.bscale[1]) * b_amount;
        params.b[1] -= (deltaY * params.bscale[0] + deltaX * params.bscale[1]) * b_amount;
    }
    if (params.drag === "zoom" && !params.julia) {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
    // if (params.drag === "distort" && params.julia) {
    //     params.a[0] += deltaX * 0.01;
    //     params.a[1] += deltaY * 0.01;
    //     params.b[0] -= deltaX * 0.01;
    //     params.b[1] -= deltaY * 0.01;
    // }
    if (params.drag === "zoom" && params.julia) {
        params.z0[0] += deltaX * params.z0Scale[0] - deltaY * params.z0Scale[1];
        params.z0[1] += deltaY * params.z0Scale[0] + deltaX * params.z0Scale[1];
    }
}

function flippen() {
    if (params.julia) {
        return;
    }
    params.flip = !params.flip;
    if (params.julia) {
        params.z0[0] = params.flip ? params.b[0] : params.a[0];
        params.z0[1] = params.flip ? params.b[1] : params.a[1];
    }
    params.last_moved = performance.now();
    params.high_count = 1;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    update_buttons();
    paint();
}

function toggle_julia() {
    params.julia = !params.julia;
    params.drag = params.julia ? "distort" : "zoom";
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    update_buttons();
    paint();
}

function set_mandelbrot_drag(mode) {
    params.drag = mode;
    update_buttons();
}

function start() {
    glStuff = setup();
    update_buttons();
    paint();
}

window.onload = start;
    </script>
    <style>
button {
    padding: 10px;
}
button.active {
    background: #ffaaaa;
}
button.disabled {
    color: #888888;
}
    </style>
</head>
<body>
    <button id="button_distort" onclick="set_mandelbrot_drag('distort')">Distort</button>
    <button id="button_zoom" onclick="set_mandelbrot_drag('zoom')">Zoom</button>
    &nbsp;
    <button id="button_flip" onclick="flippen()">Flip</button>
    &nbsp;&nbsp;&nbsp;&nbsp;
    <button id="button_julia" onclick="toggle_julia()">Julia</button>
    <br>
    <canvas id="canvas" width="400" height="800" onmousedown="mousedown()" onmousemove="mousemove()" onwheel="mousewheel()" ontouchstart="touchstart()" ontouchmove="touchmove()" ontouchend="touchend()"></canvas>
</body>
</html>