<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rational Quadratic Julia Sets</title>
    <script>
"use strict";

let params = {
    a: [0.3, 0.1],
    ascale: [0.0, 0.2],
    b: [0.3, -0.1],
    bscale: [0.25, 0.0],
    z0: [0.0, 0.0],
    z0Scale: 2.0,
    mandelbrot: true,
    color: true,
    drag: "all",
    drag_start: [0.0, 0.0],
    timer: null,
    last_moved: 0,
    high_count: 0,
    touchStartA: null,
    touchStartB: null,
    touchStartAScale: null,
    touchStartBScale: null,
    touchSide: null,
    touchStartId: null,
};
let glStuff = null;
let touches = new Map();

function fragmentShaderSource(max_iter, max_period) {
    return `
        precision highp float;
        varying vec2 a;
        varying vec2 b;
        varying vec2 z0;
        uniform bool uMandelbrot;
        uniform float uBailout;
        uniform float uBailin;
        uniform float uBrightness;

        const vec2 two = vec2(2.0, 0.0);
        const vec2 one = vec2(1.0, 0.0);

        vec2 csqrt(vec2 z) {
            float r = length(z);
            float theta = atan(z.y, z.x);
            return vec2(
                sqrt(r) * cos(theta / 2.0),
                sqrt(r) * sin(theta / 2.0)
            );
        }

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        vec2 div(vec2 x, vec2 y) {
            float denom = y.x * y.x + y.y * y.y;
            return vec2(
                (x.x * y.x + x.y * y.y) / denom,
                (x.y * y.x - x.x * y.y) / denom);
        }

        vec4 solve_quadratic(vec2 a, vec2 b, vec2 c) {
            vec2 discriminant = csqrt(mul(b, b) - 4.0 * mul(a, c));
            vec2 root1 = div(-b + discriminant, 2.0 * a);
            vec2 root2 = div(-b - discriminant, 2.0 * a);
            return vec4(root1, root2);  // return both roots packed together
        }

        vec4 mandelbrot(vec2 actual_z0) {
            vec2 z = actual_z0;
            const int max_iteration = ${max_iter};
            int iter = 0;
            vec2 prevZ = z;
            int brightness = 0;
            int period = -1;
            for (int iteration = 0; iteration < max_iteration; iteration++) {
                vec2 z2 = mul(z, z);
                z = div(
                    mul(a, z2) + mul(b - one, z),
                    mul(a - one, z) + b
                );
                if (length(z) > uBailout) {
                    period = 0;
                    brightness = iteration;
                    break;
                }

                float d = length(z - prevZ);
                if (d < uBailin && brightness == 0) {
                    brightness = iteration;
                }
                if (mod(float(iteration), 32.0) < 0.001 || iteration == ${max_iter - max_period}) {
                    prevZ = z;
                }
                if (iteration > ${max_iter - max_period}) {
                    if (d < uBailin) {
                        period = iteration - ${max_iter - max_period + 1};
                        break;
                    }
                }
            }
            // float brightnessf = 0.25 + sin(sqrt(max(float(brightness), 32.0) * 0.1)) * 0.25;
            // float brightnessf = 0.1 + log(float(brightness) + 10.0) * 0.1;
            float brightnessf = -0.6 + sqrt(max(float(brightness), 32.0) + 10.0) * 0.1;
            float theta = float(period) * 3.88;
            if (period == -1) {
                return vec4(5.0 * brightnessf, 5.0 * brightnessf, 5.0 * brightnessf, 1.0);
            }
            vec3 color = vec3(1.0 + cos(theta), 1.0 + cos(theta + 2.1), 1.0 + cos(theta + 4.2)) * brightnessf;
            return vec4(color, 1.0);
        }

        void main(void) {
            if (uMandelbrot) {
                vec4 roots = solve_quadratic(
                    mul(a, a - one),
                    2.0 * mul(a, b),
                    mul(b, b - one)
                );
                gl_FragColor = 0.5 * mandelbrot(roots.xy) + 
                               0.5 * mandelbrot(roots.zw);
            } else {
                gl_FragColor = mandelbrot(z0);
            }
        }
    `;
}
        
function setup() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("webgl");
    ctx.clearColor(1.0, 0.9, 0.9, 1.0);

    // Mandelbrot vertex shader program
    const vsSource = `
        precision highp float;
        attribute vec2 aVertexPosition;
        uniform vec2 uz0;
        uniform float uz0Scale;
        uniform vec2 ua;
        uniform vec2 ub;
        uniform vec2 uascale;
        uniform vec2 ubscale;
        uniform vec2 uNudge;
        varying vec2 a;
        varying vec2 b;
        varying vec2 z0;

        vec2 mul(vec2 x, vec2 y) {
            return vec2(
                x.x * y.x - x.y * y.y,
                x.x * y.y + x.y * y.x);
        }

        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vec2 vp = aVertexPosition * vec2(1.0, 2.0) + uNudge;
            a = ua + mul(vp, uascale);
            b = ub + mul(vp, ubscale);
            z0 = uz0 + vp * uz0Scale;
        }
    `;

    // Mandelbrot/Julia fragment shader program
    const fsSource = fragmentShaderSource(200, 32);
    const fsSourceHigh = fragmentShaderSource(2000, 100);

    // Initialize shaders
    const vertexShader = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShader, vsSource);
    ctx.compileShader(vertexShader);
    const fragmentShader = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShader, fsSource);
    ctx.compileShader(fragmentShader);
    if (!ctx.getShaderParameter(vertexShader, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShader, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the shaders: " +
            ctx.getShaderInfoLog(vertexShader) + " " +
            ctx.getShaderInfoLog(fragmentShader));
        return null;
    }
    const shaderProgram = ctx.createProgram();
    ctx.attachShader(shaderProgram, vertexShader);
    ctx.attachShader(shaderProgram, fragmentShader);
    ctx.linkProgram(shaderProgram);

    // Initialize shaders (high iteration count)
    const fragmentShaderHigh = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderHigh, fsSourceHigh);
    ctx.compileShader(fragmentShaderHigh);
    if (!ctx.getShaderParameter(fragmentShaderHigh, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the high iteration shader: " +
            ctx.getShaderInfoLog(fragmentShaderHigh));
        return null;
    }
    const shaderProgramHigh = ctx.createProgram();
    ctx.attachShader(shaderProgramHigh, vertexShader);
    ctx.attachShader(shaderProgramHigh, fragmentShaderHigh);
    ctx.linkProgram(shaderProgramHigh);

    // Shaders for texture blitting
    const vsSourceBlit = `
        attribute vec2 aVertexPosition;
        varying vec2 vTexCoord;
        void main(void) {
            gl_Position = vec4(aVertexPosition, 0.0, 1.0);
            vTexCoord = (aVertexPosition + vec2(1.0, 1.0)) * 0.5;
        }
    `;
    const fsSourceBlit = `
        precision highp float;
        varying vec2 vTexCoord;
        uniform sampler2D uTexture;
        void main(void) {
            gl_FragColor = texture2D(uTexture, vTexCoord);
        }
    `;
    const vertexShaderBlit = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderBlit, vsSourceBlit);
    ctx.compileShader(vertexShaderBlit);
    const fragmentShaderBlit = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderBlit, fsSourceBlit);
    ctx.compileShader(fragmentShaderBlit);
    if (!ctx.getShaderParameter(vertexShaderBlit, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderBlit, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the blit shaders: " +
            ctx.getShaderInfoLog(vertexShaderBlit) + " " +
            ctx.getShaderInfoLog(fragmentShaderBlit));
        return null;
    }
    const shaderProgramBlit = ctx.createProgram();
    ctx.attachShader(shaderProgramBlit, vertexShaderBlit);
    ctx.attachShader(shaderProgramBlit, fragmentShaderBlit);
    ctx.linkProgram(shaderProgramBlit);

    // Shaders for point markers
    const vsSourcePoint = `
        precision highp float;
        uniform vec2 uVertexPosition;
        uniform float uPointSize;
        void main(void) {
            gl_Position = vec4(uVertexPosition * vec2(1.0, 0.5), 0.0, 1.0);
            gl_PointSize = uPointSize;
        }
    `;
    const fsSourcePoint = `
        precision highp float;
        uniform vec3 uColor;
        void main(void) {
            gl_FragColor = vec4(uColor, 1.0);
        }
    `;
    const vertexShaderPoint = ctx.createShader(ctx.VERTEX_SHADER);
    ctx.shaderSource(vertexShaderPoint, vsSourcePoint);
    ctx.compileShader(vertexShaderPoint);
    const fragmentShaderPoint = ctx.createShader(ctx.FRAGMENT_SHADER);
    ctx.shaderSource(fragmentShaderPoint, fsSourcePoint);
    ctx.compileShader(fragmentShaderPoint);
    if (!ctx.getShaderParameter(vertexShaderPoint, ctx.COMPILE_STATUS) ||
        !ctx.getShaderParameter(fragmentShaderPoint, ctx.COMPILE_STATUS)) {
        console.error("An error occurred compiling the point shaders: " +
            ctx.getShaderInfoLog(vertexShaderPoint) + " " +
            ctx.getShaderInfoLog(fragmentShaderPoint));
        return null;
    }
    const shaderProgramPoint = ctx.createProgram();
    ctx.attachShader(shaderProgramPoint, vertexShaderPoint);
    ctx.attachShader(shaderProgramPoint, fragmentShaderPoint);
    ctx.linkProgram(shaderProgramPoint);

    // Set up square vertices
    const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
         1,  1,
    ]);
    const vertexBuffer = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, vertexBuffer);
    ctx.bufferData(ctx.ARRAY_BUFFER, vertices, ctx.STATIC_DRAW);

    // Create texture to hold low-iteration Mandelbrot image
    const fbWidth = 400;
    const fbHeight = 800;
    const destTexture = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTexture);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidth, fbHeight, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render low-iteration Mandelbrot image into
    const framebuffer = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebuffer);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTexture, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    // Create texture to hold high-iteration Mandelbrot image
    const fbWidthHigh = 400;
    const fbHeightHigh = 800;
    const destTextureHigh = ctx.createTexture();
    ctx.bindTexture(ctx.TEXTURE_2D, destTextureHigh);
    ctx.texImage2D(ctx.TEXTURE_2D, 0, ctx.RGBA, fbWidthHigh, fbHeightHigh, 0, ctx.RGBA, ctx.UNSIGNED_BYTE, null);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, ctx.LINEAR);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, ctx.CLAMP_TO_EDGE);
    ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, ctx.CLAMP_TO_EDGE);
    ctx.bindTexture(ctx.TEXTURE_2D, null);

    // Create framebuffer to render high-iteration Mandelbrot image into
    const framebufferHigh = ctx.createFramebuffer();
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, framebufferHigh);
    ctx.framebufferTexture2D(ctx.FRAMEBUFFER, ctx.COLOR_ATTACHMENT0, ctx.TEXTURE_2D, destTextureHigh, 0);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);

    return {
        main: {
            shaderProgram,
            aVertexPosition: ctx.getAttribLocation(shaderProgram, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgram, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgram, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgram, "uz0Scale"),
            ua: ctx.getUniformLocation(shaderProgram, "ua"),
            ub: ctx.getUniformLocation(shaderProgram, "ub"),
            uascale: ctx.getUniformLocation(shaderProgram, "uascale"),
            ubscale: ctx.getUniformLocation(shaderProgram, "ubscale"),
            uBailout: ctx.getUniformLocation(shaderProgram, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgram, "uBailin"),
            bailin: 0.002,
            bailout: 1000,
            uNudge: ctx.getUniformLocation(shaderProgram, "uNudge"),
            vertexBuffer,
            destTexture,
            framebuffer,
            fbWidth,
            fbHeight,
            uBrightness: ctx.getUniformLocation(shaderProgram, "uBrightness"),
            brightness: 0.02,
        },
        high: {
            shaderProgram: shaderProgramHigh,
            aVertexPosition: ctx.getAttribLocation(shaderProgramHigh, "aVertexPosition"),
            uMandelbrot: ctx.getUniformLocation(shaderProgramHigh, "uMandelbrot"),
            uz0: ctx.getUniformLocation(shaderProgramHigh, "uz0"),
            uz0Scale: ctx.getUniformLocation(shaderProgramHigh, "uz0Scale"),
            ua: ctx.getUniformLocation(shaderProgramHigh, "ua"),
            ub: ctx.getUniformLocation(shaderProgramHigh, "ub"),
            uascale: ctx.getUniformLocation(shaderProgramHigh, "uascale"),
            ubscale: ctx.getUniformLocation(shaderProgramHigh, "ubscale"),
            uBailout: ctx.getUniformLocation(shaderProgramHigh, "uBailout"),
            uBailin: ctx.getUniformLocation(shaderProgramHigh, "uBailin"),
            bailin: 0.001,
            bailout: 1000,
            uNudge: ctx.getUniformLocation(shaderProgramHigh, "uNudge"),
            vertexBuffer,
            destTexture: destTextureHigh,
            framebuffer: framebufferHigh,
            fbWidth: fbWidthHigh,
            fbHeight: fbHeightHigh,
            uBrightness: ctx.getUniformLocation(shaderProgramHigh, "uBrightness"),
            brightness: 0.02,
        },
        blit: {
            shaderProgram: shaderProgramBlit,
            aVertexPosition: ctx.getAttribLocation(shaderProgramBlit, "aVertexPosition"),
            uTexture: ctx.getUniformLocation(shaderProgramBlit, "uTexture"),
            vertexBuffer,
        },
        point: {
            shaderProgram: shaderProgramPoint,
            uVertexPosition: ctx.getUniformLocation(shaderProgramPoint, "uVertexPosition"),
            uPointSize: ctx.getUniformLocation(shaderProgramPoint, "uPointSize"),
            uColor: ctx.getUniformLocation(shaderProgramPoint, "uColor"),
        }
    };
}

function paintMandelbrot(ctx, stuff, nudgeX, nudgeY) {
    // Draw the Julia or Mandelbrot set
    ctx.useProgram(stuff.shaderProgram);
    ctx.uniform1f(stuff.uBailout, stuff.bailout);
    ctx.uniform1f(stuff.uBailin, stuff.bailin);
    ctx.uniform2f(stuff.uNudge, nudgeX, nudgeY);
    if (params.mandelbrot) {
        ctx.uniform1i(stuff.uMandelbrot, true);
        ctx.uniform1f(stuff.uz0Scale, 0.0);
        ctx.uniform2f(stuff.ua, params.a[0], params.a[1]);
        ctx.uniform2f(stuff.uascale, params.ascale[0], params.ascale[1]);
        ctx.uniform2f(stuff.ub, params.b[0], params.b[1]);
        ctx.uniform2f(stuff.ubscale, params.bscale[0], params.bscale[1]);
        ctx.uniform1f(stuff.uBrightness, stuff.brightness);
    } else {
        ctx.uniform1i(stuff.uMandelbrot, false);
        ctx.uniform1f(stuff.uz0Scale, params.z0Scale);
        ctx.uniform2f(stuff.ua, params.a[0], params.a[1]);
        ctx.uniform2f(stuff.ub, params.b[0], params.b[1]);
        ctx.uniform2f(stuff.uascale, 0.0, 0.0);
        ctx.uniform2f(stuff.ubscale, 0.0, 0.0);
        ctx.uniform2f(stuff.uz0, params.z0[0], params.z0[1]);
        ctx.uniform1f(stuff.uBrightness, stuff.brightness);
    }
    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);
}

function blit_texture(ctx, stuff, texture) {
    ctx.useProgram(stuff.shaderProgram);
    ctx.activeTexture(ctx.TEXTURE0);
    ctx.bindTexture(ctx.TEXTURE_2D, texture);
    ctx.uniform1i(stuff.uTexture, 0);

    ctx.bindBuffer(ctx.ARRAY_BUFFER, stuff.vertexBuffer);
    ctx.enableVertexAttribArray(stuff.aVertexPosition);
    ctx.vertexAttribPointer(stuff.aVertexPosition, 2, ctx.FLOAT, false, 0, 0);
    ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, 4);

    ctx.bindTexture(ctx.TEXTURE_2D, null);
}

function draw_dots(ctx, stuff) {
    for (let i = 0; i < 3; i++) {
        ctx.useProgram(stuff.shaderProgram);
        ctx.uniform2f(stuff.uVertexPosition, params.vertices[i][0], params.vertices[i][1]);
        ctx.uniform1f(stuff.uPointSize, 10.0);
        ctx.uniform3f(stuff.uColor, 0, 0, 1);

        ctx.drawArrays(ctx.POINTS, 0, 1);
    }
}

function paint() {
    const ctx = document.getElementById("canvas").getContext("webgl");
    if (params.high_count === 0) {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.main.framebuffer);
        ctx.viewport(0, 0, glStuff.main.fbWidth, glStuff.main.fbHeight);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        paintMandelbrot(ctx, glStuff.main, 0, 0);

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        ctx.clear(ctx.COLOR_BUFFER_BIT);
        blit_texture(ctx, glStuff.blit, glStuff.main.destTexture);
        // draw_dots(ctx, glStuff.point);

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        params.high_count += 1;
        params.timer = setTimeout(paint, 300);
    } else {
        ctx.bindFramebuffer(ctx.FRAMEBUFFER, glStuff.high.framebuffer);
        ctx.viewport(0, 0, glStuff.high.fbWidth, glStuff.high.fbHeight);

        if (params.high_count === 1) {
            ctx.clear(ctx.COLOR_BUFFER_BIT);
            paintMandelbrot(ctx, glStuff.high, 0, 0);
        } else {
            ctx.enable(ctx.BLEND);
            ctx.blendEquation(ctx.FUNC_ADD);
            ctx.blendFuncSeparate(ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA, ctx.CONSTANT_ALPHA, ctx.ONE_MINUS_CONSTANT_ALPHA);
            ctx.blendColor(1.0, 1.0, 1.0, 1.0 / params.high_count);
            let nudgeX = (Math.random() - 0.5) * 0.5 / 100;
            let nudgeY = (Math.random() - 0.5) * 0.5 / 100;
            paintMandelbrot(ctx, glStuff.high, nudgeX, nudgeY);
            ctx.disable(ctx.BLEND);
        }

        ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
        ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
        blit_texture(ctx, glStuff.blit, glStuff.high.destTexture);
        // draw_dots(ctx, glStuff.point);

        params.high_count += 1;

        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        if (params.high_count < 8) {
            params.timer = setTimeout(paint, 100);
        }
    }

    document.getElementById("button_ab").classList.remove("active");
    document.getElementById("button_bc").classList.remove("active");
    document.getElementById("button_ca").classList.remove("active");
    document.getElementById("button_all").classList.remove("active");
    if (params.drag === "ab") {
        document.getElementById("button_ab").classList.add("active");
    } else if (params.drag === "bc") {
        document.getElementById("button_bc").classList.add("active");
    } else if (params.drag === "ca") {
        document.getElementById("button_ca").classList.add("active");
    } else if (params.drag === "all") {
        document.getElementById("button_all").classList.add("active");
    }
}

function mousedown() {
    const x = event.clientX;
    const y = event.clientY;
    params.drag_start = [x, y];
    // update_point(x,y, false, params.last_alternate);
    event.preventDefault();
}

function mousemove() {
    const x = event.clientX;
    const y = event.clientY;
    if (event.buttons === 1) {
        move(
            -(x - params.drag_start[0]) * 0.005,
            (y - params.drag_start[1]) * 0.005
        );
        paint();
    }
    params.drag_start = [x, y];
    event.preventDefault();
}

function mousewheel() {
    const delta = event.deltaY;
    const scale = Math.exp(delta * 0.001);
    scale_rotate(scale, 0);
    paint();
    event.preventDefault();
}

function touchstart() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];

    if (touches.size === 0) {
        const offsetX = event.target.getBoundingClientRect().left;
        const offsetY = event.target.getBoundingClientRect().top;
        const x = (changedTouch.pageX - offsetX) / 200 - 1;
        const y = -(changedTouch.pageY - offsetY) / 200 + 2;

        const aVal = add(params.a, mul([x, y], params.ascale));
        const bVal = add(params.b, mul([x, y], params.bscale));
        const cVal = sub([1.0, 0.0], add(aVal, bVal));
        if (aVal > bVal && aVal > cVal) {
            params.touchSide = "a";
        } else if (bVal > cVal) {
            params.touchSide = "b";
        } else {
            params.touchSide = "c";
        }
        params.touchStartA = [params.a[0], params.a[1]];
        params.touchStartB = [params.b[0], params.b[1]];
        params.touchStartAScale = [params.ascale[0], params.ascale[1]];
        params.touchStartBScale = [params.bscale[0], params.bscale[1]];
        params.touchStartId = changedTouch.identifier;
    }

    const touch = {
        pageX: changedTouch.pageX,
        pageY: changedTouch.pageY,
        startX: changedTouch.pageX,
        startY: changedTouch.pageY,
        identifier: changedTouch.identifier,
    };

    touches.set(changedTouch.identifier, touch);
}

function touchend() {
    event.preventDefault();
    const changedTouch = event.changedTouches[0];
    const ongoingTouch = touches.get(changedTouch.identifier);
    const deltaX = changedTouch.pageX - ongoingTouch.pageX;
    const deltaY = changedTouch.pageY - ongoingTouch.pageY;
    touches.delete(changedTouch.identifier);
}

function add(x, y) {
    return [
        x[0] + y[0],
        x[1] + y[1]
    ];
}

function add3(x, y, z) {
    return [
        x[0] + y[0] + z[0],
        x[1] + y[1] + z[1]
    ];
}

function sub(x, y) {
    return [
        x[0] - y[0],
        x[1] - y[1]
    ];
}

function mul(x, y) {
    return [
        x[0] * y[0] - x[1] * y[1],
        x[0] * y[1] + x[1] * y[0]
    ];
}

function div(x, y) {
    const denom = y[0] * y[0] + y[1] * y[1];
    return [
        (x[0] * y[0] + x[1] * y[1]) / denom,
        (x[1] * y[0] - x[0] * y[1]) / denom
    ];
}

function scale(r, c) {
    return [
        r * c[0],
        r * c[1]
    ];
}

function cnorm(c) {
    return Math.hypot(c[0], c[1]);
}

function touchmove() {
    event.preventDefault();
    for (let i = 0; i < event.changedTouches.length; i++) {
        const changedTouch = event.changedTouches[i];
        const ongoingTouch = touches.get(changedTouch.identifier);
        if (ongoingTouch) {
            ongoingTouch.pageX = changedTouch.pageX;
            ongoingTouch.pageY = changedTouch.pageY;
        }
    }

    if (touches.size === 1 || touches.size === 2) {
        const offsetX = event.target.getBoundingClientRect().left;
        const offsetY = event.target.getBoundingClientRect().top;

        const touch0 = touches.get(params.touchStartId);
        if (!touch0) {
            return;
        }
        let x = -(touch0.pageX - touch0.startX) / 200;
        let y = (touch0.pageY - touch0.startY) / 200;
        let r0 = [0,0];
        let r1 = [0,0];
        for (const touch of touches.values()) {
            let sign = (touch.identifier === params.touchStartId) ? 1 : -1;
            r0[0] += sign * touch.startX;
            r0[1] -= sign * touch.startY;
            r1[0] += sign * touch.pageX;
            r1[1] -= sign * touch.pageY;
        }

        const ascaleh = cnorm(params.touchStartAScale);
        const bscaleh = cnorm(params.touchStartBScale);
        const cscaleh = cnorm(add(params.touchStartAScale, params.touchStartBScale));

        if (params.touchSide === "a") {
            const bdistrib = bscaleh / (bscaleh + cscaleh);
            const delta = mul([x,y], params.touchStartAScale);
            params.a = add(params.touchStartA, delta);
            params.b = add(params.touchStartB, scale(-bdistrib, delta));
            
            if (touches.size === 2) {
                const deltaR = sub(mul(params.touchStartAScale, div(r0, r1)), params.touchStartAScale);
                params.ascale = add(params.touchStartAScale, deltaR);
                params.bscale = add(params.touchStartBScale, scale(-1.0 * bdistrib, deltaR));
            }
        } else if (params.touchSide === "b") {
            const adistrib = ascaleh / (ascaleh + cscaleh);
            const delta = mul([x,y], params.touchStartBScale);
            params.b = add(params.touchStartB, delta);
            params.a = add(params.touchStartA, scale(-adistrib, delta));
        } else if (params.touchSide === "c") {
            const adistrib = ascaleh / (ascaleh + bscaleh);
            const delta = mul([x,y], scale(-1, add(params.touchStartAScale, params.touchStartBScale)));
            params.a = add(params.touchStartA, scale(-adistrib, delta));
            params.b = add(params.touchStartB, scale(-(1.0 - adistrib), delta));
        }

        params.last_moved = performance.now();
        params.high_count = 0;
        if (params.timer !== null) {
            clearTimeout(params.timer);
        }
        paint();
    }
}

function scale_rotate(scaleX, scaleY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.mandelbrot) {
        if (params.drag === "ca") {
            let c0 = -params.ascale[0] - params.bscale[0];
            let c1 = -params.ascale[1] - params.bscale[1];
            let cincrx = c0 * scaleX - c1 * scaleY - c0;
            let cincry = c0 * scaleY + c1 * scaleX - c1;
            params.ascale[0] -= cincrx;
            params.ascale[1] -= cincry;
        }
        if (params.drag === "bc") {
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
        if (params.drag === "ab") {
            let aincrx = params.ascale[0] * scaleX - params.ascale[1] * scaleY - params.ascale[0];
            let aincry = params.ascale[0] * scaleY + params.ascale[1] * scaleX - params.ascale[1];
            params.ascale[0] += aincrx;
            params.ascale[1] += aincry;
            params.bscale[0] -= aincrx;
            params.bscale[1] -= aincry;
        }
        if (params.drag === "all") {
            params.ascale = [
                params.ascale[0] * scaleX - params.ascale[1] * scaleY,
                params.ascale[0] * scaleY + params.ascale[1] * scaleX
            ];
            params.bscale = [
                params.bscale[0] * scaleX - params.bscale[1] * scaleY,
                params.bscale[0] * scaleY + params.bscale[1] * scaleX
            ];
        }
    } else {
        params.z0Scale /= scale;
    }
}

function move(deltaX, deltaY) {
    params.last_moved = performance.now();
    params.high_count = 0;
    if (params.timer !== null) {
        clearTimeout(params.timer);
    }
    if (params.drag === "ca") {
        const cscale = [
            (params.ascale[0] + params.bscale[0]),
            (params.ascale[1] + params.bscale[1])
        ];
        params.a[0] += deltaX * cscale[0] - deltaY * cscale[1];
        params.a[1] += deltaY * cscale[0] + deltaX * cscale[1];
    }
    if (params.drag === "bc") {
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
    if (params.drag === "ab") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] -= deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.b[1] -= deltaY * params.ascale[0] + deltaX * params.ascale[1];
    }
    if (params.drag === "all") {
        params.a[0] += deltaX * params.ascale[0] - deltaY * params.ascale[1];
        params.a[1] += deltaY * params.ascale[0] + deltaX * params.ascale[1];
        params.b[0] += deltaX * params.bscale[0] - deltaY * params.bscale[1];
        params.b[1] += deltaY * params.bscale[0] + deltaX * params.bscale[1];
    }
}

function start() {
    glStuff = setup();
    paint();
}

window.onload = start;
    </script>
    <style>
button {
    padding: 10px;
}
button.active {
    background: #ffaaaa;
}
    </style>
</head>
<body>
    <button id="button_ab" onclick="params.drag='ab'; paint()">AB</button>
    <button id="button_bc" onclick="params.drag='bc'; paint()">BC</button>
    <button id="button_ca" onclick="params.drag='ca'; paint()">CA</button>
    <button id="button_all" onclick="params.drag='all'; paint()">All</button>
    <br>
    <canvas id="canvas" width="400" height="800" onmousedown="mousedown()" onmousemove="mousemove()" onwheel="mousewheel()" ontouchstart="touchstart()" ontouchmove="touchmove()" ontouchend="touchend()"></canvas>
</body>
</html>